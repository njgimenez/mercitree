{"ast":null,"code":"var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n;\n(function (exports) {\n  'use strict';\n\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var PLUS = '+'.charCodeAt(0);\n  var SLASH = '/'.charCodeAt(0);\n  var NUMBER = '0'.charCodeAt(0);\n  var LOWER = 'a'.charCodeAt(0);\n  var UPPER = 'A'.charCodeAt(0);\n  var PLUS_URL_SAFE = '-'.charCodeAt(0);\n  var SLASH_URL_SAFE = '_'.charCodeAt(0);\n  function decode(elt) {\n    var code = elt.charCodeAt(0);\n    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'\n    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'\n    if (code < NUMBER) return -1; //no match\n    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;\n    if (code < UPPER + 26) return code - UPPER;\n    if (code < LOWER + 26) return code - LOWER + 26;\n  }\n  function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    var len = b64.length;\n    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(b64.length * 3 / 4 - placeHolders);\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n    var L = 0;\n    function push(v) {\n      arr[L++] = v;\n    }\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n      push((tmp & 0xFF0000) >> 16);\n      push((tmp & 0xFF00) >> 8);\n      push(tmp & 0xFF);\n    }\n    if (placeHolders === 2) {\n      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n      push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n      push(tmp >> 8 & 0xFF);\n      push(tmp & 0xFF);\n    }\n    return arr;\n  }\n  function uint8ToBase64(uint8) {\n    var i,\n      extraBytes = uint8.length % 3,\n      // if we have 1 byte left, pad 2 bytes\n      output = \"\",\n      temp,\n      length;\n    function encode(num) {\n      return lookup.charAt(num);\n    }\n    function tripletToBase64(num) {\n      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n    }\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n      output += tripletToBase64(temp);\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1];\n        output += encode(temp >> 2);\n        output += encode(temp << 4 & 0x3F);\n        output += '==';\n        break;\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n        output += encode(temp >> 10);\n        output += encode(temp >> 4 & 0x3F);\n        output += encode(temp << 2 & 0x3F);\n        output += '=';\n        break;\n    }\n    return output;\n  }\n  exports.toByteArray = b64ToByteArray;\n  exports.fromByteArray = uint8ToBase64;\n})(typeof exports === 'undefined' ? this.base64js = {} : exports);","map":{"version":3,"names":["lookup","exports","Arr","Uint8Array","Array","PLUS","charCodeAt","SLASH","NUMBER","LOWER","UPPER","PLUS_URL_SAFE","SLASH_URL_SAFE","decode","elt","code","b64ToByteArray","b64","i","j","l","tmp","placeHolders","arr","length","Error","len","charAt","L","push","v","uint8ToBase64","uint8","extraBytes","output","temp","encode","num","tripletToBase64","toByteArray","fromByteArray","base64js"],"sources":["/home/devdisnovo/Documentos/PROYECTOS/merci/node_modules/linebreak/node_modules/base64-js/lib/b64.js"],"sourcesContent":["var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}