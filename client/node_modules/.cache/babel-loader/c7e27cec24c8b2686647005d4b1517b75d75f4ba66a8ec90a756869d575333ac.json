{"ast":null,"code":"import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\nconst renderPath = (ctx, node) => {\n  const d = node.props?.d;\n  if (d) ctx.path(node.props.d);\n};\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  const x = node.props?.x || 0;\n  const y = node.props?.y || 0;\n  const rx = node.props?.rx || 0;\n  const ry = node.props?.ry || 0;\n  const width = node.props?.width || 0;\n  const height = node.props?.height || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\nconst renderGroup = () => {\n  // noop\n};\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = (ctx, rx, ry, cx = 0, cy = 0) => {\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, rx, ry, cx, cy);\n};\nconst renderCircle = (ctx, node) => {\n  const cx = node.props?.cx;\n  const cy = node.props?.cy;\n  const r = node.props?.r;\n  drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = n => {\n  if (n > -1e21 && n < 1e21) {\n    return Math.round(n * 1e6) / 1e6;\n  }\n  throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n  const commands = [];\n  const scale = ctx._fontSize / 1000;\n  let i;\n  let last = 0;\n  let hadOffset = false;\n  ctx.save();\n  // flip coordinate system\n  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n  y = ctx.page.height - y;\n  // add current font to page if necessary\n  if (ctx.page.fonts[ctx._font.id] == null) {\n    ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n  }\n  // begin the text object\n  ctx.addContent('BT');\n  // text position\n  ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n  // font and font size\n  ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n  // Adds a segment of text to the TJ command buffer\n  const addSegment = cur => {\n    if (last < cur) {\n      const hex = encoded.slice(last, cur).join('');\n      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n      commands.push(`<${hex}> ${number(-advance)}`);\n    }\n    return last = cur;\n  };\n  // Flushes the current TJ commands to the output stream\n  const flush = s => {\n    addSegment(s);\n    if (commands.length > 0) {\n      ctx.addContent(`[${commands.join(' ')}] TJ`);\n      return commands.length = 0;\n    }\n  };\n  for (i = 0; i < positions.length; i += 1) {\n    // If we have an x or y offset, we have to break out of the current TJ command\n    // so we can move the text position.\n    const pos = positions[i];\n    if (pos.xOffset || pos.yOffset) {\n      // Flush the current buffer\n      flush(i);\n      // Move the text position and flush just the current character\n      ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n      flush(i + 1);\n      hadOffset = true;\n    } else {\n      // If the last character had an offset, reset the text position\n      if (hadOffset) {\n        ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n        hadOffset = false;\n      }\n      // Group segments that don't have any advance adjustments\n      if (pos.xAdvance - pos.advanceWidth !== 0) {\n        addSegment(i + 1);\n      }\n    }\n    x += pos.xAdvance * scale;\n  }\n  // Flush any remaining commands\n  flush(i);\n  // end the text object\n  ctx.addContent('ET');\n  // restore flipped coordinate system\n  return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\nconst renderRun$1 = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const runAdvanceWidth = run.xAdvance;\n  const font = run.attributes.font?.[0];\n  const {\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  if (color) ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font) {\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  }\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  ctx.save();\n  const x = line.box?.x || 0;\n  const y = line.box?.y || 0;\n  const font = line.runs[0]?.attributes.font?.[0];\n  const scale = line.runs[0]?.attributes?.scale || 1;\n  const width = line.xAdvance;\n  if (!font) return;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  const children = node.children;\n  children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\nconst renderPolygon = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n  ctx.closePath();\n};\nconst renderImage$1 = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.image?.data) return;\n  const {\n    x = 0,\n    y = 0\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n    return;\n  }\n  if (typeof width === 'string' || typeof height === 'string') {\n    console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n  // Border top\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n  // Border right\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n  // Border bottom\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n  // Border left\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle = 0, yAngle = 0] = value;\n        const radx = xAngle * Math.PI / 180;\n        const rady = yAngle * Math.PI / 180;\n        const tanx = Math.tan(radx);\n        const tany = Math.tan(rady);\n        let x = 0;\n        let y = 0;\n        if (origin != null) {\n          [x, y] = Array.from(origin);\n          const x1 = x + tanx * y;\n          const y1 = y + tany * x;\n          x -= x1;\n          y -= y1;\n        }\n        ctx.transform(1, tany, tanx, 1, x, y);\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(`Transform operation: '${operation}' doesn't supported`);\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return;\n  const {\n    props,\n    style\n  } = node;\n  const origin = [node.origin.left, node.origin.top];\n  const propsTransform = 'transform' in props ? props.transform : undefined;\n  const operations = style?.transform || propsTransform || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  const r = node.props?.r || 0;\n  const cx = node.props?.cx || 0;\n  const cy = node.props?.cy || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  const cx = node.props?.cx || 0;\n  const cy = node.props?.cy || 0;\n  const rx = node.props?.rx || 0;\n  const ry = node.props?.ry || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  const x1 = node.props?.x1 || 0;\n  const y1 = node.props?.y1 || 0;\n  const x2 = node.props?.x2 || 0;\n  const y2 = node.props?.y2 || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  const x = node.props?.x || 0;\n  const y = node.props?.y || 0;\n  const width = node.props?.width || 0;\n  const height = node.props?.height || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  const points = parsePoints(node.props?.points);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\nconst setStrokeWidth = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeWidth' in node.props)) return;\n  const lineWidth = node.props.strokeWidth;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('stroke' in node.props)) return;\n  const strokeColor = node.props.stroke;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('opacity' in node.props)) return;\n  const opacity = node.props.opacity;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fillOpacity' in node.props)) return;\n  const fillOpacity = node.props.fillOpacity || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeOpacity' in node.props)) return;\n  const strokeOpacity = node.props?.strokeOpacity;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinejoin' in node.props)) return;\n  const lineJoin = node.props.strokeLinejoin;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinecap' in node.props)) return;\n  const lineCap = node.props?.strokeLinecap;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeDasharray' in node.props)) return;\n  const value = node.props?.strokeDasharray || null;\n  // @ts-expect-error check this works as expected\n  if (value) ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = node => {\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return node.props.fill?.type === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return node.props.fill?.type === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n  const a = m1[0] * m2[0] + m1[2] * m2[1];\n  const b = m1[1] * m2[0] + m1[3] * m2[1];\n  const c = m1[0] * m2[2] + m1[2] * m2[3];\n  const d = m1[1] * m2[2] + m1[3] * m2[3];\n  const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n  const matrices = transforms.map(transform => {\n    switch (transform.operation) {\n      case 'scale':\n        {\n          const value = transform.value;\n          return [value[0], 0, 0, value[1], 0, 0];\n        }\n      case 'translate':\n        {\n          const value = transform.value;\n          let x = value[0] || 0;\n          let y = value[1] || 0;\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n          return [1, 0, 0, 1, x, y];\n        }\n      case 'rotate':\n        {\n          const value = transform.value;\n          const cos = Math.cos(value[0]);\n          const sin = Math.sin(value[0]);\n          return [cos, sin, -sin, cos, 0, 0];\n        }\n      case 'skew':\n        {\n          const value = transform.value;\n          return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n        }\n      case 'matrix':\n        {\n          const value = transform.value;\n          let x = value[4] || 0;\n          let y = value[5] || 0;\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n          return [value[0], value[1], value[2], value[3], x, y];\n        }\n      default:\n        return [1, 0, 0, 1, 0, 0];\n    }\n  });\n  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n  grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = node.props?.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let x1 = gradient.props.x1 || 0;\n  let y1 = gradient.props.y1 || 0;\n  let x2 = gradient.props.x2 || 1;\n  let y2 = gradient.props.y2 || 0;\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    x1 = m0 * x1 + m4;\n    y1 = m3 * y1 + m5;\n    x2 = m0 * x2 + m4;\n    y2 = m3 * y2 + m5;\n  }\n  const grad = ctx.linearGradient(x1, y1, x2, y2);\n  transformGradient(grad, transforms, bbox, units);\n  gradient.children?.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = node.props?.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let r = gradient.props.r || 0.5;\n  let cx = gradient.props.cx || 0.5;\n  let cy = gradient.props.cy || 0.5;\n  let fx = gradient.props.fx || cx;\n  let fy = gradient.props.fy || cy;\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    r = r * m0;\n    cx = m0 * cx + m4;\n    cy = m3 * cy + m5;\n    fx = m0 * fx + m4;\n    fy = m3 * fy + m5;\n  }\n  const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n  transformGradient(grad, transforms, bbox, units);\n  gradient.children?.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const fillColor = node.props?.fill;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if ('fill' in props && props.fill) {\n    ctx.fill(props.fillRule);\n  } else if ('stroke' in props && props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(`SVG node of type ${node.type} is not currently supported`);\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  if (!node.props) return;\n  if (!('clipPath' in node.props)) return;\n  const value = node.props.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio || {};\n  if (viewBox == null || width == null || height == null) return;\n  const x = viewBox?.minX || 0;\n  const y = viewBox?.minY || 0;\n  const logicalWidth = viewBox?.maxX || width;\n  const logicalHeight = viewBox?.maxY || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\nconst black = {\n  value: '#000',\n  opacity: 1\n};\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = hex => {\n  if (!hex) return black;\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = run.attributes.font?.[0];\n  if (!font) return;\n  ctx.save();\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = run.attributes.font?.[0];\n  if (!font) return;\n  const {\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height = 0,\n    descent = 0,\n    xAdvance = 0\n  } = run;\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n  ctx.save();\n  ctx.lineWidth(decorationLine.rect.height);\n  ctx.strokeOpacity(decorationLine.opacity);\n  if (/dashed/.test(decorationLine.style)) {\n    ctx.dash(3 * decorationLine.rect.height, {});\n  } else if (/dotted/.test(decorationLine.style)) {\n    ctx.dash(decorationLine.rect.height, {});\n  }\n  if (/wavy/.test(decorationLine.style)) {\n    const dist = Math.max(2, decorationLine.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n    // Adjust step to fill entire width\n    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = decorationLine.rect.y + dist;\n    const cp2y = decorationLine.rect.y - dist;\n    let {\n      x\n    } = decorationLine.rect;\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n    if (/double/.test(decorationLine.style)) {\n      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n    }\n  }\n  ctx.stroke(decorationLine.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n  if (!line.box) return;\n  const lineAscent = line.ascent || 0;\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      const xAdvance = run.xAdvance ?? 0;\n      const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  if (line.decorationLines) {\n    for (let i = 0; i < line.decorationLines.length; i += 1) {\n      const decorationLine = line.decorationLines[i];\n      renderDecorationLine(ctx, decorationLine);\n    }\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n  block.forEach(line => {\n    renderLine(ctx, line);\n  });\n};\nconst renderText = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.lines) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = node.box?.paddingTop || 0;\n  const paddingLeft = node.box?.paddingLeft || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block);\n  });\n  ctx.restore();\n};\nconst renderPage = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = node.props?.dpi || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\nconst renderNote = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = node?.children?.[0].value || '';\n  const color = node.style?.backgroundColor;\n  ctx.note(left, top, 0, 0, value, {\n    color\n  });\n};\nconst embedImage = (ctx, node) => {\n  const src = node.image.data;\n  let image;\n  if (typeof src === 'string') {\n    image = ctx._imageRegistry[src];\n  }\n  if (!image) {\n    image = ctx.openImage(src);\n  }\n  if (!image.obj) {\n    image.embed(ctx);\n  }\n  return image;\n};\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n    yOffset: matchPercent(py ?? null) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\nconst drawImage = (ctx, node, options) => {\n  if (!node.box) return;\n  if (!node.image) return;\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = node.style?.opacity;\n  const objectFit = node.style?.objectFit;\n  const objectPositionX = node.style?.objectPositionX;\n  const objectPositionY = node.style?.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst debugMargin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), {\n    width: Infinity\n  });\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  if (!node.props) return;\n  if (!('debug' in node.props) || !node.props.debug) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => ({\n    ...acc,\n    [prop]: (...args) => {\n      // @ts-expect-error ctx[prop] is a function\n      ctx[prop](...args);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!node.box) return;\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth = 0,\n    borderLeftWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  const {\n    opacity = 1,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\nconst drawBackground = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  const hasBackground = !!node.box && !!node.style?.backgroundColor;\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\nconst isString = value => typeof value === 'string';\nconst isSrcId = value => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n  if (!src || !node.box) return;\n  const isId = isSrcId(src);\n  const method = isId ? 'goTo' : 'link';\n  const value = isId ? src.slice(1) : src;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  if ('src' in props && isString(props.src)) return renderLink(ctx, node, props.src);\n  if ('href' in props && isString(props.href)) return renderLink(ctx, node, props.href);\n};\nconst setDestination = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.props) return;\n  if ('id' in node.props) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\nconst clean = options => {\n  const opt = {\n    ...options\n  };\n  // We need to ensure the elements are no present if not true\n  Object.entries(opt).forEach(pair => {\n    if (!pair[1]) {\n      delete opt[pair[0]];\n    }\n  });\n  return opt;\n};\nconst parseCommonFormOptions = node => {\n  // Common Options\n  return {\n    required: node.props?.required || false,\n    noExport: node.props?.noExport || false,\n    readOnly: node.props?.readOnly || false,\n    value: node.props?.value || undefined,\n    defaultValue: node.props?.defaultValue || undefined\n  };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n  return clean({\n    ...parseCommonFormOptions(node),\n    parent: fieldSet || undefined,\n    align: node.props?.align || 'left',\n    multiline: node.props?.multiline || undefined,\n    password: node.props?.password || false,\n    noSpell: node.props?.noSpell || false,\n    format: node.props?.format || undefined,\n    fontSize: node.props?.fontSize || undefined,\n    MaxLen: node.props?.maxLength || undefined\n  });\n};\nconst parseSelectAndListFieldOptions = node => {\n  return clean({\n    ...parseCommonFormOptions(node),\n    sort: node.props?.sort || false,\n    edit: node.props?.edit || false,\n    multiSelect: node.props?.multiSelect || false,\n    noSpell: node.props?.noSpell || false,\n    select: node.props?.select || ['']\n  });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n  const appearance = ctx.ref({\n    Type: 'XObject',\n    Subtype: 'Form',\n    BBox: [0, 0, width, height],\n    Resources: {\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n      Font: {\n        ZaDi: ctx._acroform.fonts.ZaDi\n      }\n    }\n  });\n  appearance.initDeflate();\n  appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n  appearance.end(null);\n  return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n  const {\n    width,\n    height\n  } = node.box || {};\n  const onOption = node.props?.onState || 'Yes';\n  const offOption = node.props?.offState || 'Off';\n  const xMark = node.props?.xMark || false;\n  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n    const ref = ctx.ref({\n      Type: 'Font',\n      Subtype: 'Type1',\n      BaseFont: 'ZapfDingbats'\n    });\n    ctx._acroform.fonts.ZaDi = ref;\n    ref.end(null);\n  }\n  const normalAppearance = {\n    [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n    [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height)\n  };\n  return clean({\n    ...parseCommonFormOptions(node),\n    backgroundColor: node.props?.backgroundColor || undefined,\n    borderColor: node.props?.borderColor || undefined,\n    parent: fieldSet || undefined,\n    value: `/${node.props?.checked === true ? onOption : offOption}`,\n    defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n    AS: node.props?.checked === true ? onOption : offOption,\n    AP: {\n      N: normalAppearance,\n      D: normalAppearance\n    }\n  });\n};\nconst renderTextInput = (ctx, node, options) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = node.props?.name || '';\n  const fieldSetOptions = options.fieldSets?.at(0);\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\nconst renderSelect = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = node.props?.name || '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\nconst renderFieldSet = (ctx, node, options) => {\n  const name = node.props?.name || '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  const formField = ctx.formField(name);\n  const option = options;\n  if (!option.fieldSets) {\n    option.fieldSets = [formField];\n  } else {\n    option.fieldSets.push(formField);\n  }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n  options.fieldSets.pop();\n};\nconst renderList = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box || {};\n  // Element's name\n  const name = 'name' in node.props ? node.props.name || '' : '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\nconst renderCheckbox = (ctx, node, options) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = node.props?.name || '';\n  const fieldSetOptions = options.fieldSets?.at(0);\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.FieldSet]: renderFieldSet,\n  [P.TextInput]: renderTextInput,\n  [P.Select]: renderSelect,\n  [P.Checkbox]: renderCheckbox,\n  [P.List]: renderList,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst cleanUpFns = {\n  [P.FieldSet]: cleanUpFieldSet\n};\nconst renderNode = (ctx, node, options) => {\n  const overflowHidden = node.style?.overflow === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  const cleanUpFn = cleanUpFns[node.type];\n  if (cleanUpFn) cleanUpFn(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  if (!node.box) return;\n  if (!node.props) return;\n  if ('bookmark' in node.props && node.props.bookmark) {\n    const bookmark = node.props.bookmark;\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map(),\n    fieldSets: []\n  };\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\nexport { render as default };","map":{"version":3,"names":["P","isNil","matchPercent","absPath","parsePath","normalizePath","colorString","renderPath","ctx","node","d","props","path","KAPPA$3","Math","sqrt","renderRect","x","y","rx","ry","width","height","krx","kry","moveTo","lineTo","bezierCurveTo","closePath","renderLine$1","x1","x2","y1","y2","renderGroup","KAPPA$2","drawEllipse","cx","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","number","n","round","Error","_renderGlyphs","encoded","positions","commands","scale","_fontSize","i","last","hadOffset","save","transform","page","fonts","_font","id","ref","addContent","addSegment","cur","hex","slice","join","advance","xAdvance","advanceWidth","push","flush","s","length","pos","xOffset","yOffset","restore","renderGlyphs","glyphs","unitsPerEm","font","advanceWidthScale","encodedGlyphs","encodeGlyphs","encodedPositions","map","yAdvance","renderRun$1","run","runAdvanceWidth","attributes","fontSize","color","opacity","fillColor","fillOpacity","type","fullName","error","console","log","translate","renderSpan","line","textAnchor","dominantBaseline","box","runs","ascent","xHeight","descent","capHeight","xTranslate","yTranslate","forEach","renderSvgText","children","span","lines","pairs","values","result","parsePoints","points","trim","replace","split","mappedValues","parseFloat","drawPolyline","p","renderPolyline","renderPolygon","renderImage$1","image","data","style","paddingTop","paddingLeft","warn","href","KAPPA$1","clipNode","top","left","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","rbr","cbr","rbl","cbl","rtl","ctl","clip","applySingleTransformation","origin","operation","value","scaleX","scaleY","angle","rotate","xAngle","yAngle","radx","PI","rady","tanx","tan","tany","Array","from","applyTransformations","propsTransform","undefined","operations","getPathBoundingBox","bounds","Infinity","l","j","getCircleBoundingBox","getEllipseBoundingBox","getLineBoundingBox","max","getRectBoundingBox","getPolylineBoundingBox","xValues","yValues","boundingBoxFns","Rect","Line","Path","Circle","Ellipse","Polygon","Polyline","getBoundingBox","boundingBoxFn","setStrokeWidth","lineWidth","strokeWidth","setStrokeColor","strokeColor","stroke","setOpacity","setFillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","strokeLinejoin","setLineCap","lineCap","strokeLinecap","setLineDash","strokeDasharray","dash","Number","hasLinearGradientFill","fill","LinearGradient","hasRadialGradientFill","RadialGradient","multiplyMatrices","m1","m2","a","b","c","e","f","transformGradient","grad","transforms","bbox","units","matrices","cos","sin","matrix","reduce","setTransform","setLinearGradientFill","gradient","gradientUnits","gradientTransform","m0","m3","m4","m5","linearGradient","stop","offset","stopColor","stopOpacity","setRadialGradientFill","fx","fy","radialGradient","setFillColor","setFill","draw","fillAndStroke","fillRule","noop","renderFns$1","Tspan","TextInstance","G","Text","Image","renderNode$1","renderFn","drawNode","clipPath","child","drawChildren","resolveAspectRatio","viewBox","preserveAspectRatio","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","moveToOrigin","renderSvg","black","parseColor","parsed","get","to","DEST_REGEXP","isSrcId$1","src","match","renderAttachment","attachment","fit","valign","renderAttachments","space","glyphForCodePoint","objectReplacement","attachmentAdvance","position","glyph","renderRun","link","goTo","renderBackground$1","rect","backgroundColor","renderDecorationLine","decorationLine","test","dist","step","stepCount","floor","remainingWidth","adjustment","cp1y","cp2y","renderLine","lineAscent","isLastRun","overflowRight","backgroundRect","decorationLines","renderBlock","block","renderText","blocks","initialY","offsetX","alignOffset","renderPage","dpi","userUnit","addPage","size","margin","renderNote","note","embedImage","_imageRegistry","openImage","obj","embed","isNumeric","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","percent","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","options","objectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","imageCache","Map","cacheKey","key","set","imageOpacity","JSON","stringify","source","renderImage","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","debugMargin","marginLeft","marginTop","marginRight","marginBottom","debugText","roundedWidth","roundedHeight","text","debugOrigin","circle","renderDebug","debug","availableMethods","painter","acc","prop","args","renderCanvas","availableWidth","availableHeight","paint","KAPPA","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","drawBackground","nodeOpacity","renderBackground","hasBackground","isString","isSrcId","renderLink","isId","method","setLink","setDestination","addNamedDestination","clean","opt","Object","entries","pair","parseCommonFormOptions","required","noExport","readOnly","defaultValue","parseTextInputOptions","fieldSet","parent","multiline","password","noSpell","format","MaxLen","maxLength","parseSelectAndListFieldOptions","sort","edit","multiSelect","select","getAppearance","codepoint","appearance","Type","Subtype","BBox","Resources","ProcSet","Font","ZaDi","_acroform","initDeflate","write","end","parseCheckboxOptions","onOption","onState","offOption","offState","xMark","prototype","hasOwnProperty","call","BaseFont","normalAppearance","borderColor","checked","AS","AP","N","D","renderTextInput","name","fieldSetOptions","fieldSets","at","_root","AcroForm","initForm","formText","renderSelect","formCombo","renderFieldSet","formField","option","cleanUpFieldSet","_ctx","_node","pop","renderList","formList","renderCheckbox","formCheckbox","isRecursiveNode","Svg","renderChildren","renderChild","renderNode","renderFns","Note","FieldSet","TextInput","Select","Checkbox","List","Canvas","Link","cleanUpFns","overflowHidden","overflow","shouldRenderChildren","Page","cleanUpFn","addNodeBookmark","pageNumber","registry","bookmark","title","expanded","zoom","outline","instance","addItem","addBookmarks","root","pages","render","doc","default"],"sources":["/home/devdisnovo/Documentos/PROYECTOS/merci/node_modules/@react-pdf/render/lib/index.js"],"sourcesContent":["import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n    const d = node.props?.d;\n    if (d)\n        ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    if (!width || !height)\n        return;\n    if (rx && ry) {\n        const krx = rx * KAPPA$3;\n        const kry = ry * KAPPA$3;\n        ctx.moveTo(x + rx, y);\n        ctx.lineTo(x - rx + width, y);\n        ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n        ctx.lineTo(x + width, y + height - ry);\n        ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n        ctx.lineTo(x + rx, y + height);\n        ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n        ctx.lineTo(x, y + ry);\n        ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    }\n    else {\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + width, y);\n        ctx.lineTo(x + width, y + height);\n        ctx.lineTo(x, y + height);\n    }\n    ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n    const { x1, x2, y1, y2 } = node.props || {};\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n    // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = (ctx, rx, ry, cx = 0, cy = 0) => {\n    const x = cx - rx;\n    const y = cy - ry;\n    const ox = rx * KAPPA$2;\n    const oy = ry * KAPPA$2;\n    const xe = x + rx * 2;\n    const ye = y + ry * 2;\n    const xm = x + rx;\n    const ym = y + ry;\n    ctx.moveTo(x, ym);\n    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n    const { cx, cy, rx, ry } = node.props || {};\n    drawEllipse(ctx, rx, ry, cx, cy);\n};\n\nconst renderCircle = (ctx, node) => {\n    const cx = node.props?.cx;\n    const cy = node.props?.cy;\n    const r = node.props?.r;\n    drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = (n) => {\n    if (n > -1e21 && n < 1e21) {\n        return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n    const commands = [];\n    const scale = ctx._fontSize / 1000;\n    let i;\n    let last = 0;\n    let hadOffset = false;\n    ctx.save();\n    // flip coordinate system\n    ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n    y = ctx.page.height - y;\n    // add current font to page if necessary\n    if (ctx.page.fonts[ctx._font.id] == null) {\n        ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n    }\n    // begin the text object\n    ctx.addContent('BT');\n    // text position\n    ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    // font and font size\n    ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = (cur) => {\n        if (last < cur) {\n            const hex = encoded.slice(last, cur).join('');\n            const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n            commands.push(`<${hex}> ${number(-advance)}`);\n        }\n        return (last = cur);\n    };\n    // Flushes the current TJ commands to the output stream\n    const flush = (s) => {\n        addSegment(s);\n        if (commands.length > 0) {\n            ctx.addContent(`[${commands.join(' ')}] TJ`);\n            return (commands.length = 0);\n        }\n    };\n    for (i = 0; i < positions.length; i += 1) {\n        // If we have an x or y offset, we have to break out of the current TJ command\n        // so we can move the text position.\n        const pos = positions[i];\n        if (pos.xOffset || pos.yOffset) {\n            // Flush the current buffer\n            flush(i);\n            // Move the text position and flush just the current character\n            ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n            flush(i + 1);\n            hadOffset = true;\n        }\n        else {\n            // If the last character had an offset, reset the text position\n            if (hadOffset) {\n                ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n                hadOffset = false;\n            }\n            // Group segments that don't have any advance adjustments\n            if (pos.xAdvance - pos.advanceWidth !== 0) {\n                addSegment(i + 1);\n            }\n        }\n        x += pos.xAdvance * scale;\n    }\n    // Flush any remaining commands\n    flush(i);\n    // end the text object\n    ctx.addContent('ET');\n    // restore flipped coordinate system\n    return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n    const scale = 1000 / ctx._fontSize;\n    const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n    const advanceWidthScale = 1000 / unitsPerEm;\n    // Glyph encoding and positioning\n    const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n    const encodedPositions = positions.map((pos, i) => ({\n        xAdvance: pos.xAdvance * scale,\n        yAdvance: pos.yAdvance * scale,\n        xOffset: pos.xOffset,\n        yOffset: pos.yOffset,\n        advanceWidth: glyphs[i].advanceWidth * advanceWidthScale,\n    }));\n    return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\n\nconst renderRun$1 = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const runAdvanceWidth = run.xAdvance;\n    const font = run.attributes.font?.[0];\n    const { fontSize, color, opacity } = run.attributes;\n    if (color)\n        ctx.fillColor(color);\n    ctx.fillOpacity(opacity);\n    if (font) {\n        ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    }\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n    ctx.save();\n    const x = line.box?.x || 0;\n    const y = line.box?.y || 0;\n    const font = line.runs[0]?.attributes.font?.[0];\n    const scale = line.runs[0]?.attributes?.scale || 1;\n    const width = line.xAdvance;\n    if (!font)\n        return;\n    const ascent = font.ascent * scale;\n    const xHeight = font.xHeight * scale;\n    const descent = font.descent * scale;\n    const capHeight = font.capHeight * scale;\n    let xTranslate = x;\n    let yTranslate = y;\n    switch (textAnchor) {\n        case 'middle':\n            xTranslate = x - width / 2;\n            break;\n        case 'end':\n            xTranslate = x - width;\n            break;\n        default:\n            xTranslate = x;\n            break;\n    }\n    switch (dominantBaseline) {\n        case 'middle':\n        case 'central':\n            yTranslate = y + capHeight / 2;\n            break;\n        case 'hanging':\n            yTranslate = y + capHeight;\n            break;\n        case 'mathematical':\n            yTranslate = y + xHeight;\n            break;\n        case 'text-after-edge':\n            yTranslate = y + descent;\n            break;\n        case 'text-before-edge':\n            yTranslate = y + ascent;\n            break;\n        default:\n            yTranslate = y;\n            break;\n    }\n    ctx.translate(xTranslate, yTranslate);\n    line.runs.forEach((run) => renderRun$1(ctx, run));\n    ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n    const children = node.children;\n    children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\nconst pairs = (values) => {\n    const result = [];\n    for (let i = 0; i < values.length; i += 2) {\n        result.push([values[i], values[i + 1]]);\n    }\n    return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = (points) => {\n    let values = (points || '')\n        .trim()\n        .replace(/,/g, ' ')\n        .replace(/(\\d)-(\\d)/g, '$1 -$2')\n        .split(/\\s+/);\n    if (values.length % 2 !== 0) {\n        values = values.slice(0, -1);\n    }\n    const mappedValues = values.map(parseFloat);\n    return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n    if (points.length > 0) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        points.slice(1).forEach((p) => ctx.lineTo(p[0], p[1]));\n    }\n};\nconst renderPolyline = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n    ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.image?.data)\n        return;\n    const { x = 0, y = 0 } = node.props;\n    const { width, height, opacity } = node.style;\n    const paddingTop = node.box.paddingLeft || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    if (width === 0 || height === 0) {\n        console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n        return;\n    }\n    if (typeof width === 'string' || typeof height === 'string') {\n        console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n        return;\n    }\n    ctx.save();\n    ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n        width,\n        height,\n    });\n    ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.style)\n        return;\n    const { top, left, width, height } = node.box;\n    const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0, } = node.style;\n    // Border top\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const ctr = rtr * (1.0 - KAPPA$1);\n    ctx.moveTo(left + rtr, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n    // Border right\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const cbr = rbr * (1.0 - KAPPA$1);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n    // Border bottom\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    const cbl = rbl * (1.0 - KAPPA$1);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n    // Border left\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const ctl = rtl * (1.0 - KAPPA$1);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n    const { operation, value } = transform;\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY] = value;\n            ctx.scale(scaleX, scaleY, { origin });\n            break;\n        }\n        case 'rotate': {\n            const [angle] = value;\n            ctx.rotate(angle, { origin });\n            break;\n        }\n        case 'translate': {\n            const [x, y = 0] = value;\n            ctx.translate(x, y, { origin });\n            break;\n        }\n        case 'skew': {\n            const [xAngle = 0, yAngle = 0] = value;\n            const radx = (xAngle * Math.PI) / 180;\n            const rady = (yAngle * Math.PI) / 180;\n            const tanx = Math.tan(radx);\n            const tany = Math.tan(rady);\n            let x = 0;\n            let y = 0;\n            if (origin != null) {\n                [x, y] = Array.from(origin);\n                const x1 = x + tanx * y;\n                const y1 = y + tany * x;\n                x -= x1;\n                y -= y1;\n            }\n            ctx.transform(1, tany, tanx, 1, x, y);\n            break;\n        }\n        case 'matrix': {\n            ctx.transform(...value);\n            break;\n        }\n        default: {\n            console.error(`Transform operation: '${operation}' doesn't supported`);\n        }\n    }\n};\nconst applyTransformations = (ctx, node) => {\n    if (!node.origin)\n        return;\n    const { props, style } = node;\n    const origin = [node.origin.left, node.origin.top];\n    const propsTransform = 'transform' in props ? props.transform : undefined;\n    const operations = style?.transform || propsTransform || [];\n    operations.forEach((operation) => {\n        applySingleTransformation(ctx, operation, origin);\n    });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = (node) => {\n    const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n    if (!path.length)\n        return [0, 0, 0, 0];\n    const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    for (let i = 0, l = path.length; i < l; i += 1) {\n        const points = path[i].slice(1);\n        for (let j = 0; j < points.length; j += 2) {\n            if (points[j + 0] < bounds[0])\n                bounds[0] = points[j + 0];\n            if (points[j + 1] < bounds[1])\n                bounds[1] = points[j + 1];\n            if (points[j + 0] > bounds[2])\n                bounds[2] = points[j + 0];\n            if (points[j + 1] > bounds[3])\n                bounds[3] = points[j + 1];\n        }\n    }\n    return bounds;\n};\nconst getCircleBoundingBox = (node) => {\n    const r = node.props?.r || 0;\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = (node) => {\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = (node) => {\n    const x1 = node.props?.x1 || 0;\n    const y1 = node.props?.y1 || 0;\n    const x2 = node.props?.x2 || 0;\n    const y2 = node.props?.y2 || 0;\n    return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n    ];\n};\nconst getRectBoundingBox = (node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    return [x, y, x + width, y + height];\n};\nconst max = (values) => Math.max(-Infinity, ...values);\nconst min = (values) => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = (node) => {\n    const points = parsePoints(node.props?.points);\n    const xValues = points.map((p) => p[0]);\n    const yValues = points.map((p) => p[1]);\n    return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n    [P.Rect]: getRectBoundingBox,\n    [P.Line]: getLineBoundingBox,\n    [P.Path]: getPathBoundingBox,\n    [P.Circle]: getCircleBoundingBox,\n    [P.Ellipse]: getEllipseBoundingBox,\n    [P.Polygon]: getPolylineBoundingBox,\n    [P.Polyline]: getPolylineBoundingBox,\n};\nconst getBoundingBox = (node) => {\n    const boundingBoxFn = boundingBoxFns[node.type];\n    return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeWidth' in node.props))\n        return;\n    const lineWidth = node.props.strokeWidth;\n    if (lineWidth)\n        ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('stroke' in node.props))\n        return;\n    const strokeColor = node.props.stroke;\n    if (strokeColor)\n        ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('opacity' in node.props))\n        return;\n    const opacity = node.props.opacity;\n    if (!isNil(opacity))\n        ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fillOpacity' in node.props))\n        return;\n    const fillOpacity = node.props.fillOpacity || null;\n    if (!isNil(fillOpacity))\n        ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeOpacity' in node.props))\n        return;\n    const strokeOpacity = node.props?.strokeOpacity;\n    if (!isNil(strokeOpacity))\n        ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinejoin' in node.props))\n        return;\n    const lineJoin = node.props.strokeLinejoin;\n    if (lineJoin)\n        ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinecap' in node.props))\n        return;\n    const lineCap = node.props?.strokeLinecap;\n    if (lineCap)\n        ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeDasharray' in node.props))\n        return;\n    const value = node.props?.strokeDasharray || null;\n    // @ts-expect-error check this works as expected\n    if (value)\n        ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.LinearGradient;\n};\nconst hasRadialGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n    const a = m1[0] * m2[0] + m1[2] * m2[1];\n    const b = m1[1] * m2[0] + m1[3] * m2[1];\n    const c = m1[0] * m2[2] + m1[2] * m2[3];\n    const d = m1[1] * m2[2] + m1[3] * m2[3];\n    const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n    const matrices = transforms.map((transform) => {\n        switch (transform.operation) {\n            case 'scale': {\n                const value = transform.value;\n                return [value[0], 0, 0, value[1], 0, 0];\n            }\n            case 'translate': {\n                const value = transform.value;\n                let x = value[0] || 0;\n                let y = value[1] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [1, 0, 0, 1, x, y];\n            }\n            case 'rotate': {\n                const value = transform.value;\n                const cos = Math.cos(value[0]);\n                const sin = Math.sin(value[0]);\n                return [cos, sin, -sin, cos, 0, 0];\n            }\n            case 'skew': {\n                const value = transform.value;\n                return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n            }\n            case 'matrix': {\n                const value = transform.value;\n                let x = value[4] || 0;\n                let y = value[5] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [value[0], value[1], value[2], value[3], x, y];\n            }\n            default:\n                return [1, 0, 0, 1, 0, 0];\n        }\n    });\n    const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n    grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let x1 = gradient.props.x1 || 0;\n    let y1 = gradient.props.y1 || 0;\n    let x2 = gradient.props.x2 || 1;\n    let y2 = gradient.props.y2 || 0;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        x1 = m0 * x1 + m4;\n        y1 = m3 * y1 + m5;\n        x2 = m0 * x2 + m4;\n        y2 = m3 * y2 + m5;\n    }\n    const grad = ctx.linearGradient(x1, y1, x2, y2);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let r = gradient.props.r || 0.5;\n    let cx = gradient.props.cx || 0.5;\n    let cy = gradient.props.cy || 0.5;\n    let fx = gradient.props.fx || cx;\n    let fy = gradient.props.fy || cy;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        r = r * m0;\n        cx = m0 * cx + m4;\n        cy = m3 * cy + m5;\n        fx = m0 * fx + m4;\n        fy = m3 * fy + m5;\n    }\n    const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const fillColor = node.props?.fill;\n    if (fillColor)\n        ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n    if (hasLinearGradientFill(node))\n        return setLinearGradientFill(ctx, node);\n    if (hasRadialGradientFill(node))\n        return setRadialGradientFill(ctx, node);\n    return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n    const props = node.props || {};\n    if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n        ctx.fillAndStroke(props.fillRule);\n    }\n    else if ('fill' in props && props.fill) {\n        ctx.fill(props.fillRule);\n    }\n    else if ('stroke' in props && props.stroke) {\n        ctx.stroke();\n    }\n    else {\n        ctx.save();\n        ctx.opacity(0);\n        ctx.fill(null);\n        ctx.restore();\n    }\n};\nconst noop = () => { };\nconst renderFns$1 = {\n    [P.Tspan]: noop,\n    [P.TextInstance]: noop,\n    [P.Path]: renderPath,\n    [P.Rect]: renderRect,\n    [P.Line]: renderLine$1,\n    [P.G]: renderGroup,\n    [P.Text]: renderSvgText,\n    [P.Circle]: renderCircle,\n    [P.Image]: renderImage$1,\n    [P.Ellipse]: renderEllipse,\n    [P.Polygon]: renderPolygon,\n    [P.Polyline]: renderPolyline,\n};\nconst renderNode$1 = (ctx, node) => {\n    const renderFn = renderFns$1[node.type];\n    if (renderFn) {\n        renderFn(ctx, node);\n    }\n    else {\n        console.warn(`SVG node of type ${node.type} is not currently supported`);\n    }\n};\nconst drawNode = (ctx, node) => {\n    setLineCap(ctx, node);\n    setLineDash(ctx, node);\n    setLineJoin(ctx, node);\n    setStrokeWidth(ctx, node);\n    setStrokeColor(ctx, node);\n    setFill(ctx, node);\n    setStrokeOpacity(ctx, node);\n    setFillOpacity(ctx, node);\n    setOpacity(ctx, node);\n    applyTransformations(ctx, node);\n    renderNode$1(ctx, node);\n    draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('clipPath' in node.props))\n        return;\n    const value = node.props.clipPath;\n    if (value) {\n        const children = value.children || [];\n        children.forEach((child) => renderNode$1(ctx, child));\n        ctx.clip();\n    }\n};\nconst drawChildren = (ctx, node) => {\n    const children = node.children || [];\n    children.forEach((child) => {\n        ctx.save();\n        clipPath(ctx, child);\n        drawNode(ctx, child);\n        drawChildren(ctx, child);\n        ctx.restore();\n    });\n};\nconst resolveAspectRatio = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const { viewBox, preserveAspectRatio } = node.props;\n    const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio || {};\n    if (viewBox == null || width == null || height == null)\n        return;\n    const x = viewBox?.minX || 0;\n    const y = viewBox?.minY || 0;\n    const logicalWidth = viewBox?.maxX || width;\n    const logicalHeight = viewBox?.maxY || height;\n    const logicalRatio = logicalWidth / logicalHeight;\n    const physicalRatio = width / height;\n    const scaleX = width / logicalWidth;\n    const scaleY = height / logicalHeight;\n    if (align === 'none') {\n        ctx.scale(scaleX, scaleY);\n        ctx.translate(-x, -y);\n        return;\n    }\n    if ((logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n        (logicalRatio >= physicalRatio && meetOrSlice === 'slice')) {\n        ctx.scale(scaleY, scaleY);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMinYMid':\n            case 'xMinYMax':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMidYMin':\n            case 'xMidYMid':\n            case 'xMidYMax':\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height) / 2, -y);\n                break;\n            default:\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height), -y);\n        }\n    }\n    else {\n        ctx.scale(scaleX, scaleX);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMidYMin':\n            case 'xMaxYMin':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMinYMid':\n            case 'xMidYMid':\n            case 'xMaxYMid':\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width) / 2);\n                break;\n            default:\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width));\n        }\n    }\n};\nconst moveToOrigin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingTop = node.box.paddingTop || 0;\n    ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n    ctx.save();\n    clipNode(ctx, node);\n    moveToOrigin(ctx, node);\n    resolveAspectRatio(ctx, node);\n    drawChildren(ctx, node);\n    ctx.restore();\n};\n\nconst black = { value: '#000', opacity: 1 };\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = (hex) => {\n    if (!hex)\n        return black;\n    const parsed = colorString.get(hex);\n    if (!parsed)\n        return black;\n    const value = colorString.to.hex(parsed.value.slice(0, 3));\n    const opacity = parsed.value[3];\n    return { value, opacity };\n};\n\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = (src) => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n    const { xOffset = 0, yOffset = 0, width, height, image } = attachment;\n    ctx.translate(-width + xOffset, -height + yOffset);\n    ctx.image(image, 0, 0, {\n        fit: [width, height],\n        align: 'center',\n        valign: 'bottom',\n    });\n};\nconst renderAttachments = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    ctx.save();\n    const space = font.glyphForCodePoint(0x20);\n    const objectReplacement = font.glyphForCodePoint(0xfffc);\n    let attachmentAdvance = 0;\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n        const position = run.positions[i];\n        const glyph = run.glyphs[i];\n        attachmentAdvance += position.xAdvance || 0;\n        if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n            ctx.translate(attachmentAdvance, position.yOffset || 0);\n            renderAttachment(ctx, run.attributes.attachment);\n            run.glyphs[i] = space;\n            attachmentAdvance = 0;\n        }\n    }\n    ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    const { fontSize, link } = run.attributes;\n    const color = parseColor(run.attributes.color);\n    const opacity = isNil(run.attributes.opacity)\n        ? color.opacity\n        : run.attributes.opacity;\n    const { height = 0, descent = 0, xAdvance = 0 } = run;\n    ctx.fillColor(color.value);\n    ctx.fillOpacity(opacity);\n    if (link) {\n        if (isSrcId$1(link)) {\n            ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n        }\n        else {\n            ctx.link(0, -height - descent, xAdvance, height, link);\n        }\n    }\n    renderAttachments(ctx, run);\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n    const color = parseColor(backgroundColor);\n    ctx.save();\n    ctx.fillOpacity(color.opacity);\n    ctx.rect(rect.x, rect.y, rect.width, rect.height);\n    ctx.fill(color.value);\n    ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n    ctx.save();\n    ctx.lineWidth(decorationLine.rect.height);\n    ctx.strokeOpacity(decorationLine.opacity);\n    if (/dashed/.test(decorationLine.style)) {\n        ctx.dash(3 * decorationLine.rect.height, {});\n    }\n    else if (/dotted/.test(decorationLine.style)) {\n        ctx.dash(decorationLine.rect.height, {});\n    }\n    if (/wavy/.test(decorationLine.style)) {\n        const dist = Math.max(2, decorationLine.rect.height);\n        let step = 1.1 * dist;\n        const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n        // Adjust step to fill entire width\n        const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n        const adjustment = remainingWidth / stepCount / 2;\n        step += adjustment;\n        const cp1y = decorationLine.rect.y + dist;\n        const cp2y = decorationLine.rect.y - dist;\n        let { x } = decorationLine.rect;\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        for (let i = 0; i < stepCount; i += 1) {\n            ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n            x += 2 * step;\n        }\n    }\n    else {\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n        if (/double/.test(decorationLine.style)) {\n            ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n            ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n        }\n    }\n    ctx.stroke(decorationLine.color);\n    ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n    if (!line.box)\n        return;\n    const lineAscent = line.ascent || 0;\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y + lineAscent);\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const isLastRun = i === line.runs.length - 1;\n        if (run.attributes.backgroundColor) {\n            const xAdvance = run.xAdvance ?? 0;\n            const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n            const backgroundRect = {\n                x: 0,\n                y: -lineAscent,\n                height: line.box.height,\n                width: xAdvance - overflowRight,\n            };\n            renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n        }\n        renderRun(ctx, run);\n    }\n    ctx.restore();\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y);\n    if (line.decorationLines) {\n        for (let i = 0; i < line.decorationLines.length; i += 1) {\n            const decorationLine = line.decorationLines[i];\n            renderDecorationLine(ctx, decorationLine);\n        }\n    }\n    ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n    block.forEach((line) => {\n        renderLine(ctx, line);\n    });\n};\nconst renderText = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.lines)\n        return;\n    const { top, left } = node.box;\n    const blocks = [node.lines];\n    const paddingTop = node.box?.paddingTop || 0;\n    const paddingLeft = node.box?.paddingLeft || 0;\n    const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n    const offsetX = node.alignOffset || 0;\n    ctx.save();\n    ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n    blocks.forEach((block) => {\n        renderBlock(ctx, block);\n    });\n    ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const dpi = node.props?.dpi || 72;\n    const userUnit = dpi / 72;\n    ctx.addPage({ size: [width, height], margin: 0, userUnit });\n};\n\nconst renderNote = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const value = node?.children?.[0].value || '';\n    const color = node.style?.backgroundColor;\n    ctx.note(left, top, 0, 0, value, { color });\n};\n\nconst embedImage = (ctx, node) => {\n    const src = node.image.data;\n    let image;\n    if (typeof src === 'string') {\n        image = ctx._imageRegistry[src];\n    }\n    if (!image) {\n        image = ctx.openImage(src);\n    }\n    if (!image.obj) {\n        image.embed(ctx);\n    }\n    return image;\n};\n\nconst isNumeric = (n) => {\n    return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n    const cr = cw / ch;\n    const ir = iw / ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const height = ch;\n        const width = height * ir;\n        const yOffset = isNumeric(py) ? py : 0;\n        const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n        return { width, height, xOffset, yOffset };\n    }\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n    const width = iw;\n    const height = ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, xOffset, yOffset };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n    const ir = iw / ih;\n    const cr = cw / ch;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const width = cw;\n        const height = width / ir;\n        const xOffset = isNumeric(px) ? px : 0;\n        const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n        return { width, height, yOffset, xOffset };\n    }\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n    const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n    const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    return containDimension.width < noneDimension.width\n        ? containDimension\n        : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n    return {\n        width: cw,\n        height: ch,\n        xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n        yOffset: matchPercent(py ?? null) ? 0 : py || 0,\n    };\n};\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n    switch (type) {\n        case 'contain':\n            return applyContainObjectFit(cw, ch, iw, ih, px, py);\n        case 'cover':\n            return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n        case 'none':\n            return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n        case 'scale-down':\n            return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n        default:\n            return applyFillObjectFit(cw, ch, px, py);\n    }\n};\n\nconst drawImage = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    if (!node.image)\n        return;\n    const { left, top } = node.box;\n    const opacity = node.style?.opacity;\n    const objectFit = node.style?.objectFit;\n    const objectPositionX = node.style?.objectPositionX;\n    const objectPositionY = node.style?.objectPositionY;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const imageCache = options.imageCache || new Map();\n    const { width, height, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n    if (node.image.data) {\n        if (width !== 0 && height !== 0) {\n            const cacheKey = node.image.key;\n            const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n            if (cacheKey)\n                imageCache.set(cacheKey, image);\n            const imageOpacity = isNil(opacity) ? 1 : opacity;\n            ctx\n                .fillOpacity(imageOpacity)\n                .image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n                width,\n                height,\n            });\n        }\n        else {\n            console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n        }\n    }\n};\nconst renderImage = (ctx, node, options) => {\n    ctx.save();\n    clipNode(ctx, node);\n    drawImage(ctx, node, options);\n    ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx\n        .fillColor(CONTENT_COLOR)\n        .opacity(0.5)\n        .rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth)\n        .fill();\n};\nconst debugPadding = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n    // Padding top\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop)\n        .fill();\n    // Padding left\n    ctx\n        .rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding right\n    ctx\n        .rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding bottom\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom)\n        .fill();\n};\nconst debugMargin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n    // Margin left\n    ctx\n        .rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom)\n        .fill();\n    // Margin right\n    ctx\n        .rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom)\n        .fill();\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx\n        .fontSize(6)\n        .opacity(1)\n        .fillColor('black')\n        .text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });\n};\nconst debugOrigin = (ctx, node) => {\n    if (node.origin) {\n        ctx\n            .circle(node.origin.left, node.origin.top, 3)\n            .fill('red')\n            .circle(node.origin.left, node.origin.top, 5)\n            .stroke('red');\n    }\n};\nconst renderDebug = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('debug' in node.props) || !node.props.debug)\n        return;\n    ctx.save();\n    debugContent(ctx, node);\n    debugPadding(ctx, node);\n    debugMargin(ctx, node);\n    debugText(ctx, node);\n    debugOrigin(ctx, node);\n    ctx.restore();\n};\n\nconst availableMethods = [\n    'dash',\n    'clip',\n    'save',\n    'path',\n    'fill',\n    'font',\n    'text',\n    'rect',\n    'scale',\n    'moveTo',\n    'lineTo',\n    'stroke',\n    'rotate',\n    'circle',\n    'lineCap',\n    'opacity',\n    'ellipse',\n    'polygon',\n    'restore',\n    'lineJoin',\n    'fontSize',\n    'fillColor',\n    'lineWidth',\n    'translate',\n    'miterLimit',\n    'strokeColor',\n    'fillOpacity',\n    'roundedRect',\n    'fillAndStroke',\n    'strokeOpacity',\n    'bezierCurveTo',\n    'quadraticCurveTo',\n    'linearGradient',\n    'radialGradient',\n];\nconst painter = (ctx) => {\n    const p = availableMethods.reduce((acc, prop) => ({\n        ...acc,\n        [prop]: (...args) => {\n            // @ts-expect-error ctx[prop] is a function\n            ctx[prop](...args);\n            return p;\n        },\n    }), {});\n    return p;\n};\nconst renderCanvas = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const availableWidth = width - paddingLeft - paddingRight;\n    const availableHeight = height - paddingTop - paddingBottom;\n    if (!availableWidth || !availableHeight) {\n        console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n    }\n    ctx.save().translate(left + paddingLeft, top + paddingTop);\n    if (node.props.paint) {\n        node.props.paint(painter(ctx), availableWidth, availableHeight);\n    }\n    ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c0 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n    // Move down in case the margin exceedes the radius\n    const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n    ctx.lineTo(left + width, topRightYCoord);\n    // Clip inner top right cap\n    ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n    // Clip inner top border edge\n    ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n    ctx.lineTo(left, topLeftYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c5 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border top cap joins\n    if (borderRightWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width } = layout;\n    const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rtl * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.strokeColor(borderTopColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n    if (borderTopStyle === 'dashed') {\n        ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n    }\n    else if (borderTopStyle === 'dotted') {\n        ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n    // Clip outer right border edge\n    ctx.moveTo(left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer bottom right cap\n    const c0 = rbr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    // Move left in case the margin exceedes the radius\n    const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n    ctx.lineTo(topBottomXCoord, top + height);\n    // Clip inner bottom right cap\n    ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n    // Ellipse coefficients inner bottom right cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n    // Clip inner right border edge\n    ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n    const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n    ctx.lineTo(topRightXCoord, top);\n    // Move right in case the margin exceedes the radius\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c5 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderTopWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbr * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    ctx.strokeColor(borderRightColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderRightStyle === 'dashed') {\n        ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n    }\n    else if (borderRightStyle === 'dotted') {\n        ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c0 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    // Move up in case the margin exceedes the radius\n    const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n    ctx.lineTo(left, bottomLeftYCoord);\n    // Clip inner bottom left cap\n    ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner bottom left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n    // Clip inner bottom border edge\n    ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n    // Ellipse coefficients inner top left cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n    ctx.lineTo(left + width, bottomRightYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer top left cap\n    const c5 = rbr * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border bottom cap joins\n    if (borderRightWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rbr * (1.0 - KAPPA);\n    ctx.moveTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.strokeColor(borderBottomColor);\n    ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n    if (borderBottomStyle === 'dashed') {\n        ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n    }\n    else if (borderBottomStyle === 'dotted') {\n        ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n    // Clip outer left border edge\n    ctx.moveTo(left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c0 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    // Move right in case the margin exceedes the radius\n    const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n    ctx.lineTo(topLeftCoordX, top);\n    // Clip inner top left cap\n    ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n    // Clip inner left border edge\n    ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n    // Ellipse coefficients inner bottom left cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n    ctx.lineTo(bottomLeftXCoord, top + height);\n    // Move left in case the margin exceedes the radius\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c5 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderBottomWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, height } = layout;\n    const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rtl * (1.0 - KAPPA);\n    ctx.moveTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n    ctx.strokeColor(borderLeftColor);\n    ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderLeftStyle === 'dashed') {\n        ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n    }\n    else if (borderLeftStyle === 'dotted') {\n        ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst shouldRenderBorders = (node) => node.box &&\n    (node.box.borderTopWidth ||\n        node.box.borderRightWidth ||\n        node.box.borderBottomWidth ||\n        node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!shouldRenderBorders(node))\n        return;\n    const { width, height, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    const { opacity = 1, borderTopColor = 'black', borderTopStyle = 'solid', borderLeftColor = 'black', borderLeftStyle = 'solid', borderRightColor = 'black', borderRightStyle = 'solid', borderBottomColor = 'black', borderBottomStyle = 'solid', } = node.style;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n    const style = {\n        borderTopColor,\n        borderTopWidth,\n        borderTopStyle,\n        borderLeftColor,\n        borderLeftWidth,\n        borderLeftStyle,\n        borderRightColor,\n        borderRightWidth,\n        borderRightStyle,\n        borderBottomColor,\n        borderBottomWidth,\n        borderBottomStyle};\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    ctx.save();\n    ctx.strokeOpacity(opacity);\n    if (borderTopWidth) {\n        ctx.save();\n        clipBorderTop(ctx, node.box, style, rtr, rtl);\n        fillBorderTop(ctx, node.box, style, rtr, rtl);\n        ctx.restore();\n    }\n    if (borderRightWidth) {\n        ctx.save();\n        clipBorderRight(ctx, node.box, style, rtr, rbr);\n        fillBorderRight(ctx, node.box, style, rtr, rbr);\n        ctx.restore();\n    }\n    if (borderBottomWidth) {\n        ctx.save();\n        clipBorderBottom(ctx, node.box, style, rbl, rbr);\n        fillBorderBottom(ctx, node.box, style, rbl, rbr);\n        ctx.restore();\n    }\n    if (borderLeftWidth) {\n        ctx.save();\n        clipBorderLeft(ctx, node.box, style, rbl, rtl);\n        fillBorderLeft(ctx, node.box, style, rbl, rtl);\n        ctx.restore();\n    }\n    ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const color = parseColor(node.style.backgroundColor);\n    const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n    const opacity = Math.min(color.opacity, nodeOpacity);\n    ctx\n        .fillOpacity(opacity)\n        .fillColor(color.value)\n        .rect(left, top, width, height)\n        .fill();\n};\nconst renderBackground = (ctx, node) => {\n    const hasBackground = !!node.box && !!node.style?.backgroundColor;\n    if (hasBackground) {\n        ctx.save();\n        clipNode(ctx, node);\n        drawBackground(ctx, node);\n        ctx.restore();\n    }\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isSrcId = (value) => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n    if (!src || !node.box)\n        return;\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    const { top, left, width, height } = node.box;\n    ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n    const props = node.props || {};\n    if ('src' in props && isString(props.src))\n        return renderLink(ctx, node, props.src);\n    if ('href' in props && isString(props.href))\n        return renderLink(ctx, node, props.href);\n};\n\nconst setDestination = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('id' in node.props) {\n        ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n};\n\nconst clean = (options) => {\n    const opt = { ...options };\n    // We need to ensure the elements are no present if not true\n    Object.entries(opt).forEach((pair) => {\n        if (!pair[1]) {\n            delete opt[pair[0]];\n        }\n    });\n    return opt;\n};\nconst parseCommonFormOptions = (node) => {\n    // Common Options\n    return {\n        required: node.props?.required || false,\n        noExport: node.props?.noExport || false,\n        readOnly: node.props?.readOnly || false,\n        value: node.props?.value || undefined,\n        defaultValue: node.props?.defaultValue || undefined,\n    };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        parent: fieldSet || undefined,\n        align: node.props?.align || 'left',\n        multiline: node.props?.multiline || undefined,\n        password: node.props?.password || false,\n        noSpell: node.props?.noSpell || false,\n        format: node.props?.format || undefined,\n        fontSize: node.props?.fontSize || undefined,\n        MaxLen: node.props?.maxLength || undefined,\n    });\n};\nconst parseSelectAndListFieldOptions = (node) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        sort: node.props?.sort || false,\n        edit: node.props?.edit || false,\n        multiSelect: node.props?.multiSelect || false,\n        noSpell: node.props?.noSpell || false,\n        select: node.props?.select || [''],\n    });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n    const appearance = ctx.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        BBox: [0, 0, width, height],\n        Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Font: {\n                ZaDi: ctx._acroform.fonts.ZaDi,\n            },\n        },\n    });\n    appearance.initDeflate();\n    appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n    appearance.end(null);\n    return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n    const { width, height } = node.box || {};\n    const onOption = node.props?.onState || 'Yes';\n    const offOption = node.props?.offState || 'Off';\n    const xMark = node.props?.xMark || false;\n    if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n        const ref = ctx.ref({\n            Type: 'Font',\n            Subtype: 'Type1',\n            BaseFont: 'ZapfDingbats',\n        });\n        ctx._acroform.fonts.ZaDi = ref;\n        ref.end(null);\n    }\n    const normalAppearance = {\n        [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n        [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height),\n    };\n    return clean({\n        ...parseCommonFormOptions(node),\n        backgroundColor: node.props?.backgroundColor || undefined,\n        borderColor: node.props?.borderColor || undefined,\n        parent: fieldSet || undefined,\n        value: `/${node.props?.checked === true ? onOption : offOption}`,\n        defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n        AS: node.props?.checked === true ? onOption : offOption,\n        AP: { N: normalAppearance, D: normalAppearance },\n    });\n};\n\nconst renderTextInput = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\n\nconst renderSelect = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderFieldSet = (ctx, node, options) => {\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    const formField = ctx.formField(name);\n    const option = options;\n    if (!option.fieldSets) {\n        option.fieldSets = [formField];\n    }\n    else {\n        option.fieldSets.push(formField);\n    }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n    options.fieldSets.pop();\n};\n\nconst renderList = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box || {};\n    // Element's name\n    const name = ('name' in node.props ? node.props.name || '' : '');\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderCheckbox = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\n\nconst isRecursiveNode = (node) => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n    ctx.save();\n    if (node.box) {\n        ctx.translate(node.box.left, node.box.top);\n    }\n    const children = node.children || [];\n    const renderChild = (child) => renderNode(ctx, child, options);\n    children.forEach(renderChild);\n    ctx.restore();\n};\nconst renderFns = {\n    [P.Text]: renderText,\n    [P.Note]: renderNote,\n    [P.Image]: renderImage,\n    [P.FieldSet]: renderFieldSet,\n    [P.TextInput]: renderTextInput,\n    [P.Select]: renderSelect,\n    [P.Checkbox]: renderCheckbox,\n    [P.List]: renderList,\n    [P.Canvas]: renderCanvas,\n    [P.Svg]: renderSvg,\n    [P.Link]: setLink,\n};\nconst cleanUpFns = {\n    [P.FieldSet]: cleanUpFieldSet,\n};\nconst renderNode = (ctx, node, options) => {\n    const overflowHidden = node.style?.overflow === 'hidden';\n    const shouldRenderChildren = isRecursiveNode(node);\n    if (node.type === P.Page)\n        renderPage(ctx, node);\n    ctx.save();\n    if (overflowHidden)\n        clipNode(ctx, node);\n    applyTransformations(ctx, node);\n    renderBackground(ctx, node);\n    renderBorders(ctx, node);\n    const renderFn = renderFns[node.type];\n    if (renderFn)\n        renderFn(ctx, node, options);\n    if (shouldRenderChildren)\n        renderChildren(ctx, node, options);\n    const cleanUpFn = cleanUpFns[node.type];\n    if (cleanUpFn)\n        cleanUpFn(ctx, node, options);\n    setDestination(ctx, node);\n    renderDebug(ctx, node);\n    ctx.restore();\n};\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('bookmark' in node.props && node.props.bookmark) {\n        const bookmark = node.props.bookmark;\n        const { title, parent, expanded, zoom, fit } = bookmark;\n        const outline = registry[parent] || ctx.outline;\n        const top = bookmark.top || node.box.top;\n        const left = bookmark.left || node.box.left;\n        const instance = outline.addItem(title, {\n            pageNumber,\n            expanded,\n            top,\n            left,\n            zoom,\n            fit,\n        });\n        registry[bookmark.ref] = instance;\n    }\n    if (!node.children)\n        return;\n    node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n    const registry = {};\n    const pages = root.children || [];\n    pages.forEach((page, i) => {\n        addNodeBookmark(ctx, page, i, registry);\n    });\n};\n\nconst render = (ctx, doc) => {\n    const pages = doc.children || [];\n    const options = { imageCache: new Map(), fieldSets: [] };\n    pages.forEach((page) => renderNode(ctx, page, options));\n    addBookmarks(ctx, doc);\n    ctx.end();\n    return ctx;\n};\n\nexport { render as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}