{"ast":null,"code":"import { compose, castArray, parseFloat as parseFloat$1, matchPercent } from '@react-pdf/fns';\nimport matchMedia from 'media-engine';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\n\n/**\n * Remove nil values from array\n *\n * @param array - Style array\n * @returns Style array without nils\n */\nconst compact = array => array.filter(Boolean);\n/**\n * Merges style objects array\n *\n * @param styles - Style array\n * @returns Merged style object\n */\nconst mergeStyles = styles => styles.reduce((acc, style) => {\n  const s = Array.isArray(style) ? flatten(style) : style;\n  Object.keys(s).forEach(key => {\n    if (s[key] !== null && s[key] !== undefined) {\n      acc[key] = s[key];\n    }\n  });\n  return acc;\n}, {});\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param styles - Style or style array\n * @returns Flattened style object\n */\nconst flatten = compose(mergeStyles, compact, castArray);\n\n/**\n * Resolves media queries in styles object\n *\n * @param container - Container for which styles are resolved\n * @param style - Style description\n * @returns Resolved style object\n */\nconst resolveMediaQueries = (container, style) => {\n  return Object.keys(style).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return {\n        ...acc,\n        ...matchMedia({\n          [key]: style[key]\n        }, container)\n      };\n    }\n    return {\n      ...acc,\n      [key]: style[key]\n    };\n  }, {});\n};\nconst isRgb = value => /rgba?/g.test(value);\nconst isHsl = value => /hsla?/g.test(value);\n/**\n * Transform rgb color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseRgb = value => {\n  const rgb = colorString.get.rgb(value);\n  return colorString.to.hex(rgb);\n};\n/**\n * Transform Hsl color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseHsl = value => {\n  const hsl = colorString.get.hsl(value).map(Math.round);\n  const hex = hlsToHex(...hsl);\n  return hex.toUpperCase();\n};\n/**\n * Transform given color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformColor = value => {\n  if (isRgb(value)) return parseRgb(value);\n  if (isHsl(value)) return parseHsl(value);\n  return value;\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = value => {\n  if (typeof value === 'number') return {\n    value,\n    unit: undefined\n  };\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n/**\n * Transform given scalar value\n *\n * @param container\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformUnit = (container, value) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const inputDpi = container.dpi || 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  if (typeof scalar.value !== 'number') return scalar.value;\n  switch (scalar.unit) {\n    case 'rem':\n      return scalar.value * (container.remBase || 18);\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst processNumberValue = (key, value) => ({\n  [key]: parseFloat$1(value)\n});\nconst processUnitValue = (key, value, container) => ({\n  [key]: transformUnit(container, value)\n});\nconst processColorValue = (key, value) => {\n  const result = {\n    [key]: transformColor(value)\n  };\n  return result;\n};\nconst processNoopValue = (key, value) => ({\n  [key]: value\n});\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = value => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst resolveBorderShorthand = (key, value, container) => {\n  const match = matchBorderShorthand(`${value}`);\n  if (match) {\n    const widthMatch = match[1] || value;\n    const styleMatch = match[4] || value;\n    const colorMatch = match[5] || value;\n    const style = styleMatch;\n    const color = colorMatch ? transformColor(colorMatch) : undefined;\n    const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\n    if (key.match(/(Top|Right|Bottom|Left)$/)) {\n      return {\n        [`${key}Color`]: color,\n        [`${key}Style`]: style,\n        [`${key}Width`]: width\n      };\n    }\n    if (key.match(/Color$/)) {\n      return {\n        borderTopColor: color,\n        borderRightColor: color,\n        borderBottomColor: color,\n        borderLeftColor: color\n      };\n    }\n    if (key.match(/Style$/)) {\n      if (typeof style === 'number') throw new Error(`Invalid border style: ${style}`);\n      return {\n        borderTopStyle: style,\n        borderRightStyle: style,\n        borderBottomStyle: style,\n        borderLeftStyle: style\n      };\n    }\n    if (key.match(/Width$/)) {\n      if (typeof width !== 'number') throw new Error(`Invalid border width: ${width}`);\n      return {\n        borderTopWidth: width,\n        borderRightWidth: width,\n        borderBottomWidth: width,\n        borderLeftWidth: width\n      };\n    }\n    if (key.match(/Radius$/)) {\n      const radius = value ? transformUnit(container, value) : undefined;\n      if (typeof radius !== 'number') throw new Error(`Invalid border radius: ${radius}`);\n      return {\n        borderTopLeftRadius: radius,\n        borderTopRightRadius: radius,\n        borderBottomRightRadius: radius,\n        borderBottomLeftRadius: radius\n      };\n    }\n    if (typeof width !== 'number') throw new Error(`Invalid border width: ${width}`);\n    if (typeof style === 'number') throw new Error(`Invalid border style: ${style}`);\n    return {\n      borderTopColor: color,\n      borderTopStyle: style,\n      borderTopWidth: width,\n      borderRightColor: color,\n      borderRightStyle: style,\n      borderRightWidth: width,\n      borderBottomColor: color,\n      borderBottomStyle: style,\n      borderBottomWidth: width,\n      borderLeftColor: color,\n      borderLeftStyle: style,\n      borderLeftWidth: width\n    };\n  }\n  return {\n    [key]: value\n  };\n};\nconst handlers$b = {\n  border: resolveBorderShorthand,\n  borderBottom: resolveBorderShorthand,\n  borderBottomColor: processColorValue,\n  borderBottomLeftRadius: processUnitValue,\n  borderBottomRightRadius: processUnitValue,\n  borderBottomStyle: processNoopValue,\n  borderBottomWidth: processUnitValue,\n  borderColor: resolveBorderShorthand,\n  borderLeft: resolveBorderShorthand,\n  borderLeftColor: processColorValue,\n  borderLeftStyle: processNoopValue,\n  borderLeftWidth: processUnitValue,\n  borderRadius: resolveBorderShorthand,\n  borderRight: resolveBorderShorthand,\n  borderRightColor: processColorValue,\n  borderRightStyle: processNoopValue,\n  borderRightWidth: processUnitValue,\n  borderStyle: resolveBorderShorthand,\n  borderTop: resolveBorderShorthand,\n  borderTopColor: processColorValue,\n  borderTopLeftRadius: processUnitValue,\n  borderTopRightRadius: processUnitValue,\n  borderTopStyle: processNoopValue,\n  borderTopWidth: processUnitValue,\n  borderWidth: resolveBorderShorthand\n};\nconst handlers$a = {\n  backgroundColor: processColorValue,\n  color: processColorValue,\n  opacity: processNumberValue\n};\nconst handlers$9 = {\n  height: processUnitValue,\n  maxHeight: processUnitValue,\n  maxWidth: processUnitValue,\n  minHeight: processUnitValue,\n  minWidth: processUnitValue,\n  width: processUnitValue\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\nconst flexAuto = [1, 1, 'auto'];\nconst processFlexShorthand = (key, value, container) => {\n  let defaults = flexDefaults;\n  let matches = [];\n  if (value === 'auto') {\n    defaults = flexAuto;\n  } else {\n    matches = `${value}`.split(' ');\n  }\n  const flexGrow = parseFloat$1(matches[0] || defaults[0]);\n  const flexShrink = parseFloat$1(matches[1] || defaults[1]);\n  const flexBasis = transformUnit(container, matches[2] || defaults[2]);\n  return {\n    flexGrow,\n    flexShrink,\n    flexBasis\n  };\n};\nconst handlers$8 = {\n  alignContent: processNoopValue,\n  alignItems: processNoopValue,\n  alignSelf: processNoopValue,\n  flex: processFlexShorthand,\n  flexBasis: processUnitValue,\n  flexDirection: processNoopValue,\n  flexFlow: processNoopValue,\n  flexGrow: processNumberValue,\n  flexShrink: processNumberValue,\n  flexWrap: processNoopValue,\n  justifyContent: processNoopValue,\n  justifySelf: processNoopValue\n};\nconst processGapShorthand = (key, value, container) => {\n  const match = `${value}`.split(' ');\n  const rowGap = transformUnit(container, match?.[0] || value);\n  const columnGap = transformUnit(container, match?.[1] || value);\n  return {\n    rowGap,\n    columnGap\n  };\n};\nconst handlers$7 = {\n  gap: processGapShorthand,\n  columnGap: processUnitValue,\n  rowGap: processUnitValue\n};\nconst handlers$6 = {\n  aspectRatio: processNumberValue,\n  bottom: processUnitValue,\n  display: processNoopValue,\n  left: processUnitValue,\n  position: processNoopValue,\n  right: processUnitValue,\n  top: processUnitValue,\n  overflow: processNoopValue,\n  zIndex: processNumberValue\n};\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n  const name = style.toString();\n  // eslint-disable-next-line no-console\n  console.error(`\n    @react-pdf/stylesheet parsing error:\n    ${name}: ${value},\n    ${' '.repeat(name.length + 2)}^\n    Unsupported ${name} value format\n  `);\n};\n/**\n * @param options\n * @param [options.expandsTo]\n * @param [options.maxValues]\n * @param [options.autoSupported]\n */\nconst expandBoxModel = ({\n  expandsTo,\n  maxValues = 1,\n  autoSupported = false\n} = {}) => (model, value, container) => {\n  const nodes = parse$1(`${value}`);\n  const parts = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    // value contains `calc`, `url` or other css function\n    // `,`, `/` or strings that unsupported by margin and padding\n    if (node.type === 'function' || node.type === 'string' || node.type === 'div') {\n      logError(model, value);\n      return {};\n    }\n    if (node.type === 'word') {\n      if (node.value === 'auto' && autoSupported) {\n        parts.push(node.value);\n      } else {\n        const result = parseUnit(node.value);\n        // when unit isn't specified this condition is true\n        if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n          parts.push(node.value);\n        } else {\n          logError(model, value);\n          return {};\n        }\n      }\n    }\n  }\n  // checks that we have enough parsed values\n  if (parts.length > maxValues) {\n    logError(model, value);\n    return {};\n  }\n  const first = transformUnit(container, parts[0]);\n  if (expandsTo) {\n    const second = transformUnit(container, parts[1] || parts[0]);\n    const third = transformUnit(container, parts[2] || parts[0]);\n    const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\n    return expandsTo({\n      first,\n      second,\n      third,\n      fourth\n    });\n  }\n  return {\n    [model]: first\n  };\n};\nconst processMargin = expandBoxModel({\n  expandsTo: ({\n    first,\n    second,\n    third,\n    fourth\n  }) => ({\n    marginTop: first,\n    marginRight: second,\n    marginBottom: third,\n    marginLeft: fourth\n  }),\n  maxValues: 4,\n  autoSupported: true\n});\nconst processMarginVertical = expandBoxModel({\n  expandsTo: ({\n    first,\n    second\n  }) => ({\n    marginTop: first,\n    marginBottom: second\n  }),\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginHorizontal = expandBoxModel({\n  expandsTo: ({\n    first,\n    second\n  }) => ({\n    marginRight: first,\n    marginLeft: second\n  }),\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginSingle = expandBoxModel({\n  autoSupported: true\n});\nconst handlers$5 = {\n  margin: processMargin,\n  marginBottom: processMarginSingle,\n  marginHorizontal: processMarginHorizontal,\n  marginLeft: processMarginSingle,\n  marginRight: processMarginSingle,\n  marginTop: processMarginSingle,\n  marginVertical: processMarginVertical\n};\nconst processPadding = expandBoxModel({\n  expandsTo: ({\n    first,\n    second,\n    third,\n    fourth\n  }) => ({\n    paddingTop: first,\n    paddingRight: second,\n    paddingBottom: third,\n    paddingLeft: fourth\n  }),\n  maxValues: 4\n});\nconst processPaddingVertical = expandBoxModel({\n  expandsTo: ({\n    first,\n    second\n  }) => ({\n    paddingTop: first,\n    paddingBottom: second\n  }),\n  maxValues: 2\n});\nconst processPaddingHorizontal = expandBoxModel({\n  expandsTo: ({\n    first,\n    second\n  }) => ({\n    paddingRight: first,\n    paddingLeft: second\n  }),\n  maxValues: 2\n});\nconst processPaddingSingle = expandBoxModel();\nconst handlers$4 = {\n  padding: processPadding,\n  paddingBottom: processPaddingSingle,\n  paddingHorizontal: processPaddingHorizontal,\n  paddingLeft: processPaddingSingle,\n  paddingRight: processPaddingSingle,\n  paddingTop: processPaddingSingle,\n  paddingVertical: processPaddingVertical\n};\nconst offsetKeyword = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return value;\n  }\n};\nconst processObjectPosition = (key, value, container) => {\n  const match = `${value}`.split(' ');\n  const objectPositionX = offsetKeyword(transformUnit(container, match?.[0] || value));\n  const objectPositionY = offsetKeyword(transformUnit(container, match?.[1] || value));\n  return {\n    objectPositionX,\n    objectPositionY\n  };\n};\nconst processObjectPositionValue = (key, value, container) => ({\n  [key]: offsetKeyword(transformUnit(container, value))\n});\nconst handlers$3 = {\n  objectPosition: processObjectPosition,\n  objectPositionX: processObjectPositionValue,\n  objectPositionY: processObjectPositionValue,\n  objectFit: processNoopValue\n};\nconst castInt = value => {\n  if (typeof value === 'number') return value;\n  return parseInt(value, 10);\n};\nconst FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nconst transformFontWeight = value => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  const lv = value.toLowerCase();\n  if (FONT_WEIGHTS[lv]) return FONT_WEIGHTS[lv];\n  return castInt(value);\n};\nconst processFontWeight = (key, value) => {\n  return {\n    [key]: transformFontWeight(value)\n  };\n};\nconst transformLineHeight = (value, styles, container) => {\n  if (value === '') return value;\n  const fontSize = transformUnit(container, styles.fontSize || 18);\n  const lineHeight = transformUnit(container, value);\n  // Percent values: use this number multiplied by the element's font size\n  const {\n    percent\n  } = matchPercent(lineHeight) || {};\n  if (percent) return percent * fontSize;\n  // Unitless values: use this number multiplied by the element's font size\n  return isNaN(value) ? lineHeight : lineHeight * fontSize;\n};\nconst processLineHeight = (key, value, container, styles) => {\n  return {\n    [key]: transformLineHeight(value, styles, container)\n  };\n};\nconst handlers$2 = {\n  direction: processNoopValue,\n  fontFamily: processNoopValue,\n  fontSize: processUnitValue,\n  fontStyle: processNoopValue,\n  fontWeight: processFontWeight,\n  letterSpacing: processUnitValue,\n  lineHeight: processLineHeight,\n  maxLines: processNumberValue,\n  textAlign: processNoopValue,\n  textDecoration: processNoopValue,\n  textDecorationColor: processColorValue,\n  textDecorationStyle: processNoopValue,\n  textIndent: processNoopValue,\n  textOverflow: processNoopValue,\n  textTransform: processNoopValue,\n  verticalAlign: processNoopValue\n};\nconst matchNumber = value => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = value => {\n  if (typeof value !== 'string') return value;\n  if (matchNumber(value)) return parseFloat(value);\n  return value;\n};\nconst parse = transformString => {\n  const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n  // Handle \"initial\", \"inherit\", \"unset\".\n  if (transforms.length === 1) {\n    return [[transforms[0], true]];\n  }\n  const parsed = [];\n  for (let i = 0; i < transforms.length; i += 1) {\n    const transform = transforms[i];\n    if (transform) {\n      const [name, rawValue] = transform.split('(');\n      const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n      const value = rawValue.split(splitChar).map(val => val.trim());\n      parsed.push({\n        operation: name.trim(),\n        value\n      });\n    }\n  }\n  return parsed;\n};\nconst parseAngle = value => {\n  const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n  const [, angle, unit] = unitsRegexp.exec(value);\n  const number = Number.parseFloat(angle);\n  return unit === 'rad' ? number * 180 / Math.PI : number;\n};\nconst normalizeTransformOperation = ({\n  operation,\n  value\n}) => {\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY = scaleX] = value.map(num => Number.parseFloat(num));\n        return {\n          operation: 'scale',\n          value: [scaleX, scaleY]\n        };\n      }\n    case 'scaleX':\n      {\n        return {\n          operation: 'scale',\n          value: [Number.parseFloat(value), 1]\n        };\n      }\n    case 'scaleY':\n      {\n        return {\n          operation: 'scale',\n          value: [1, Number.parseFloat(value)]\n        };\n      }\n    case 'rotate':\n      {\n        return {\n          operation: 'rotate',\n          value: [parseAngle(value)]\n        };\n      }\n    case 'translate':\n      {\n        return {\n          operation: 'translate',\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n    case 'translateX':\n      {\n        return {\n          operation: 'translate',\n          value: [Number.parseFloat(value), 0]\n        };\n      }\n    case 'translateY':\n      {\n        return {\n          operation: 'translate',\n          value: [0, Number.parseFloat(value)]\n        };\n      }\n    case 'skew':\n      {\n        return {\n          operation: 'skew',\n          value: value.map(parseAngle)\n        };\n      }\n    case 'skewX':\n      {\n        return {\n          operation: 'skew',\n          value: [parseAngle(value), 0]\n        };\n      }\n    case 'skewY':\n      {\n        return {\n          operation: 'skew',\n          value: [0, parseAngle(value)]\n        };\n      }\n    default:\n      {\n        return {\n          operation,\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n  }\n};\nconst normalize = operations => {\n  return operations.map(operation => normalizeTransformOperation(operation));\n};\nconst processTransform = (key, value) => {\n  if (typeof value !== 'string') return {\n    [key]: value\n  };\n  return {\n    [key]: normalize(parse(value))\n  };\n};\nconst Y_AXIS_SHORTHANDS = {\n  top: true,\n  bottom: true\n};\nconst sortTransformOriginPair = (a, b) => {\n  if (Y_AXIS_SHORTHANDS[a]) return 1;\n  if (Y_AXIS_SHORTHANDS[b]) return -1;\n  return 0;\n};\nconst getTransformOriginPair = values => {\n  if (!values || values.length === 0) return ['center', 'center'];\n  const pair = values.length === 1 ? [values[0], 'center'] : values;\n  return pair.sort(sortTransformOriginPair);\n};\n// Transforms shorthand transformOrigin values\nconst processTransformOriginShorthand = (key, value, container) => {\n  const match = `${value}`.split(' ');\n  const pair = getTransformOriginPair(match);\n  const transformOriginX = transformUnit(container, pair[0]);\n  const transformOriginY = transformUnit(container, pair[1]);\n  return {\n    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\n    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)\n  };\n};\nconst processTransformOriginValue = (key, value, container) => {\n  const v = transformUnit(container, value);\n  return {\n    [key]: offsetKeyword(v) || castFloat(v)\n  };\n};\nconst handlers$1 = {\n  transform: processTransform,\n  gradientTransform: processTransform,\n  transformOrigin: processTransformOriginShorthand,\n  transformOriginX: processTransformOriginValue,\n  transformOriginY: processTransformOriginValue\n};\nconst handlers = {\n  fill: processColorValue,\n  stroke: processColorValue,\n  strokeDasharray: processNoopValue,\n  strokeWidth: processUnitValue,\n  fillOpacity: processNumberValue,\n  strokeOpacity: processNumberValue,\n  fillRule: processNoopValue,\n  textAnchor: processNoopValue,\n  strokeLinecap: processNoopValue,\n  strokeLinejoin: processNoopValue,\n  visibility: processNoopValue,\n  clipPath: processNoopValue,\n  dominantBaseline: processNoopValue\n};\nconst shorthands = {\n  ...handlers$b,\n  ...handlers$a,\n  ...handlers$9,\n  ...handlers$8,\n  ...handlers$7,\n  ...handlers$6,\n  ...handlers$5,\n  ...handlers$4,\n  ...handlers$3,\n  ...handlers$2,\n  ...handlers$1,\n  ...handlers\n};\n/**\n * Expand the shorthand properties.\n *\n * @param style - Style object\n * @returns Expanded style object\n */\nconst resolve = container => style => {\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = style[key];\n    if (!shorthands[key]) {\n      resolvedStyle[key] = value;\n      continue;\n    }\n    const resolved = shorthands[key](key, value, container, style);\n    const keys = Object.keys(resolved);\n    for (let j = 0; j < keys.length; j += 1) {\n      const propName = keys[j];\n      const propValue = resolved[propName];\n      resolvedStyle[propName] = propValue;\n    }\n  }\n  return resolvedStyle;\n};\n\n/**\n * Resolves styles\n *\n * @param container\n * @param style - Style\n * @returns Resolved style\n */\nconst resolveStyles = (container, style) => {\n  const computeMediaQueries = value => resolveMediaQueries(container, value);\n  return compose(resolve(container), computeMediaQueries, flatten)(style);\n};\nexport { resolveStyles as default, flatten, transformColor };","map":{"version":3,"names":["compose","castArray","parseFloat","parseFloat$1","matchPercent","matchMedia","hlsToHex","colorString","parse$1","parseUnit","compact","array","filter","Boolean","mergeStyles","styles","reduce","acc","style","s","Array","isArray","flatten","Object","keys","forEach","key","undefined","resolveMediaQueries","container","test","isRgb","value","isHsl","parseRgb","rgb","get","to","hex","parseHsl","hsl","map","Math","round","toUpperCase","transformColor","parseValue","unit","match","exec","transformUnit","scalar","outputDpi","inputDpi","dpi","mmFactor","cmFactor","remBase","height","width","processNumberValue","processUnitValue","processColorValue","result","processNoopValue","BORDER_SHORTHAND_REGEX","matchBorderShorthand","resolveBorderShorthand","widthMatch","styleMatch","colorMatch","color","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","Error","borderTopStyle","borderRightStyle","borderBottomStyle","borderLeftStyle","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","handlers$b","border","borderBottom","borderColor","borderLeft","borderRadius","borderRight","borderStyle","borderTop","borderWidth","handlers$a","backgroundColor","opacity","handlers$9","maxHeight","maxWidth","minHeight","minWidth","flexDefaults","flexAuto","processFlexShorthand","defaults","matches","split","flexGrow","flexShrink","flexBasis","handlers$8","alignContent","alignItems","alignSelf","flex","flexDirection","flexFlow","flexWrap","justifyContent","justifySelf","processGapShorthand","rowGap","columnGap","handlers$7","gap","handlers$6","aspectRatio","bottom","display","left","position","right","top","overflow","zIndex","BOX_MODEL_UNITS","logError","name","toString","console","error","repeat","length","expandBoxModel","expandsTo","maxValues","autoSupported","model","nodes","parts","i","node","type","push","includes","first","second","third","fourth","processMargin","marginTop","marginRight","marginBottom","marginLeft","processMarginVertical","processMarginHorizontal","processMarginSingle","handlers$5","margin","marginHorizontal","marginVertical","processPadding","paddingTop","paddingRight","paddingBottom","paddingLeft","processPaddingVertical","processPaddingHorizontal","processPaddingSingle","handlers$4","padding","paddingHorizontal","paddingVertical","offsetKeyword","processObjectPosition","objectPositionX","objectPositionY","processObjectPositionValue","handlers$3","objectPosition","objectFit","castInt","parseInt","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","transformFontWeight","lv","toLowerCase","processFontWeight","transformLineHeight","fontSize","lineHeight","percent","isNaN","processLineHeight","handlers$2","direction","fontFamily","fontStyle","fontWeight","letterSpacing","maxLines","textAlign","textDecoration","textDecorationColor","textDecorationStyle","textIndent","textOverflow","textTransform","verticalAlign","matchNumber","castFloat","parse","transformString","transforms","trim","parsed","transform","rawValue","splitChar","indexOf","val","operation","parseAngle","unitsRegexp","angle","number","Number","PI","normalizeTransformOperation","scaleX","scaleY","num","normalize","operations","processTransform","Y_AXIS_SHORTHANDS","sortTransformOriginPair","a","b","getTransformOriginPair","values","pair","sort","processTransformOriginShorthand","transformOriginX","transformOriginY","processTransformOriginValue","v","handlers$1","gradientTransform","transformOrigin","handlers","fill","stroke","strokeDasharray","strokeWidth","fillOpacity","strokeOpacity","fillRule","textAnchor","strokeLinecap","strokeLinejoin","visibility","clipPath","dominantBaseline","shorthands","resolve","propsArray","resolvedStyle","resolved","j","propName","propValue","resolveStyles","computeMediaQueries","default"],"sources":["/home/devdisnovo/Documentos/PROYECTOS/merci/node_modules/@react-pdf/stylesheet/lib/index.js"],"sourcesContent":["import { compose, castArray, parseFloat as parseFloat$1, matchPercent } from '@react-pdf/fns';\nimport matchMedia from 'media-engine';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\n\n/**\n * Remove nil values from array\n *\n * @param array - Style array\n * @returns Style array without nils\n */\nconst compact = (array) => array.filter(Boolean);\n/**\n * Merges style objects array\n *\n * @param styles - Style array\n * @returns Merged style object\n */\nconst mergeStyles = (styles) => styles.reduce((acc, style) => {\n    const s = Array.isArray(style) ? flatten(style) : style;\n    Object.keys(s).forEach((key) => {\n        if (s[key] !== null && s[key] !== undefined) {\n            acc[key] = s[key];\n        }\n    });\n    return acc;\n}, {});\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param styles - Style or style array\n * @returns Flattened style object\n */\nconst flatten = compose(mergeStyles, compact, (castArray));\n\n/**\n * Resolves media queries in styles object\n *\n * @param container - Container for which styles are resolved\n * @param style - Style description\n * @returns Resolved style object\n */\nconst resolveMediaQueries = (container, style) => {\n    return Object.keys(style).reduce((acc, key) => {\n        if (/@media/.test(key)) {\n            return {\n                ...acc,\n                ...matchMedia({ [key]: style[key] }, container),\n            };\n        }\n        return { ...acc, [key]: style[key] };\n    }, {});\n};\n\nconst isRgb = (value) => /rgba?/g.test(value);\nconst isHsl = (value) => /hsla?/g.test(value);\n/**\n * Transform rgb color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseRgb = (value) => {\n    const rgb = colorString.get.rgb(value);\n    return colorString.to.hex(rgb);\n};\n/**\n * Transform Hsl color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseHsl = (value) => {\n    const hsl = colorString.get.hsl(value).map(Math.round);\n    const hex = hlsToHex(...hsl);\n    return hex.toUpperCase();\n};\n/**\n * Transform given color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformColor = (value) => {\n    if (isRgb(value))\n        return parseRgb(value);\n    if (isHsl(value))\n        return parseHsl(value);\n    return value;\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = (value) => {\n    if (typeof value === 'number')\n        return { value, unit: undefined };\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n    return match\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\n        : { value, unit: undefined };\n};\n/**\n * Transform given scalar value\n *\n * @param container\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformUnit = (container, value) => {\n    const scalar = parseValue(value);\n    const outputDpi = 72;\n    const inputDpi = container.dpi || 72;\n    const mmFactor = (1 / 25.4) * outputDpi;\n    const cmFactor = (1 / 2.54) * outputDpi;\n    if (typeof scalar.value !== 'number')\n        return scalar.value;\n    switch (scalar.unit) {\n        case 'rem':\n            return scalar.value * (container.remBase || 18);\n        case 'in':\n            return scalar.value * outputDpi;\n        case 'mm':\n            return scalar.value * mmFactor;\n        case 'cm':\n            return scalar.value * cmFactor;\n        case 'vh':\n            return scalar.value * (container.height / 100);\n        case 'vw':\n            return scalar.value * (container.width / 100);\n        case 'px':\n            return Math.round(scalar.value * (outputDpi / inputDpi));\n        default:\n            return scalar.value;\n    }\n};\n\nconst processNumberValue = (key, value) => ({\n    [key]: parseFloat$1(value),\n});\nconst processUnitValue = (key, value, container) => ({\n    [key]: transformUnit(container, value),\n});\nconst processColorValue = (key, value) => {\n    const result = { [key]: transformColor(value) };\n    return result;\n};\nconst processNoopValue = (key, value) => ({\n    [key]: value,\n});\n\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = (value) => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst resolveBorderShorthand = (key, value, container) => {\n    const match = matchBorderShorthand(`${value}`);\n    if (match) {\n        const widthMatch = match[1] || value;\n        const styleMatch = match[4] || value;\n        const colorMatch = match[5] || value;\n        const style = styleMatch;\n        const color = colorMatch ? transformColor(colorMatch) : undefined;\n        const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\n        if (key.match(/(Top|Right|Bottom|Left)$/)) {\n            return {\n                [`${key}Color`]: color,\n                [`${key}Style`]: style,\n                [`${key}Width`]: width,\n            };\n        }\n        if (key.match(/Color$/)) {\n            return {\n                borderTopColor: color,\n                borderRightColor: color,\n                borderBottomColor: color,\n                borderLeftColor: color,\n            };\n        }\n        if (key.match(/Style$/)) {\n            if (typeof style === 'number')\n                throw new Error(`Invalid border style: ${style}`);\n            return {\n                borderTopStyle: style,\n                borderRightStyle: style,\n                borderBottomStyle: style,\n                borderLeftStyle: style,\n            };\n        }\n        if (key.match(/Width$/)) {\n            if (typeof width !== 'number')\n                throw new Error(`Invalid border width: ${width}`);\n            return {\n                borderTopWidth: width,\n                borderRightWidth: width,\n                borderBottomWidth: width,\n                borderLeftWidth: width,\n            };\n        }\n        if (key.match(/Radius$/)) {\n            const radius = value ? transformUnit(container, value) : undefined;\n            if (typeof radius !== 'number')\n                throw new Error(`Invalid border radius: ${radius}`);\n            return {\n                borderTopLeftRadius: radius,\n                borderTopRightRadius: radius,\n                borderBottomRightRadius: radius,\n                borderBottomLeftRadius: radius,\n            };\n        }\n        if (typeof width !== 'number')\n            throw new Error(`Invalid border width: ${width}`);\n        if (typeof style === 'number')\n            throw new Error(`Invalid border style: ${style}`);\n        return {\n            borderTopColor: color,\n            borderTopStyle: style,\n            borderTopWidth: width,\n            borderRightColor: color,\n            borderRightStyle: style,\n            borderRightWidth: width,\n            borderBottomColor: color,\n            borderBottomStyle: style,\n            borderBottomWidth: width,\n            borderLeftColor: color,\n            borderLeftStyle: style,\n            borderLeftWidth: width,\n        };\n    }\n    return { [key]: value };\n};\nconst handlers$b = {\n    border: (resolveBorderShorthand),\n    borderBottom: (resolveBorderShorthand),\n    borderBottomColor: (processColorValue),\n    borderBottomLeftRadius: (processUnitValue),\n    borderBottomRightRadius: (processUnitValue),\n    borderBottomStyle: (processNoopValue),\n    borderBottomWidth: (processUnitValue),\n    borderColor: (resolveBorderShorthand),\n    borderLeft: (resolveBorderShorthand),\n    borderLeftColor: (processColorValue),\n    borderLeftStyle: (processNoopValue),\n    borderLeftWidth: (processUnitValue),\n    borderRadius: (resolveBorderShorthand),\n    borderRight: (resolveBorderShorthand),\n    borderRightColor: (processColorValue),\n    borderRightStyle: (processNoopValue),\n    borderRightWidth: (processUnitValue),\n    borderStyle: (resolveBorderShorthand),\n    borderTop: (resolveBorderShorthand),\n    borderTopColor: (processColorValue),\n    borderTopLeftRadius: (processUnitValue),\n    borderTopRightRadius: (processUnitValue),\n    borderTopStyle: (processNoopValue),\n    borderTopWidth: (processUnitValue),\n    borderWidth: (resolveBorderShorthand),\n};\n\nconst handlers$a = {\n    backgroundColor: (processColorValue),\n    color: (processColorValue),\n    opacity: (processNumberValue),\n};\n\nconst handlers$9 = {\n    height: (processUnitValue),\n    maxHeight: (processUnitValue),\n    maxWidth: (processUnitValue),\n    minHeight: (processUnitValue),\n    minWidth: (processUnitValue),\n    width: (processUnitValue),\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\nconst flexAuto = [1, 1, 'auto'];\nconst processFlexShorthand = (key, value, container) => {\n    let defaults = flexDefaults;\n    let matches = [];\n    if (value === 'auto') {\n        defaults = flexAuto;\n    }\n    else {\n        matches = `${value}`.split(' ');\n    }\n    const flexGrow = parseFloat$1(matches[0] || defaults[0]);\n    const flexShrink = parseFloat$1(matches[1] || defaults[1]);\n    const flexBasis = transformUnit(container, matches[2] || defaults[2]);\n    return { flexGrow, flexShrink, flexBasis };\n};\nconst handlers$8 = {\n    alignContent: (processNoopValue),\n    alignItems: (processNoopValue),\n    alignSelf: (processNoopValue),\n    flex: (processFlexShorthand),\n    flexBasis: (processUnitValue),\n    flexDirection: (processNoopValue),\n    flexFlow: (processNoopValue),\n    flexGrow: (processNumberValue),\n    flexShrink: (processNumberValue),\n    flexWrap: (processNoopValue),\n    justifyContent: (processNoopValue),\n    justifySelf: (processNoopValue),\n};\n\nconst processGapShorthand = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const rowGap = transformUnit(container, match?.[0] || value);\n    const columnGap = transformUnit(container, match?.[1] || value);\n    return { rowGap, columnGap };\n};\nconst handlers$7 = {\n    gap: (processGapShorthand),\n    columnGap: (processUnitValue),\n    rowGap: (processUnitValue),\n};\n\nconst handlers$6 = {\n    aspectRatio: (processNumberValue),\n    bottom: (processUnitValue),\n    display: (processNoopValue),\n    left: (processUnitValue),\n    position: (processNoopValue),\n    right: (processUnitValue),\n    top: (processUnitValue),\n    overflow: (processNoopValue),\n    zIndex: (processNumberValue),\n};\n\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n    const name = style.toString();\n    // eslint-disable-next-line no-console\n    console.error(`\n    @react-pdf/stylesheet parsing error:\n    ${name}: ${value},\n    ${' '.repeat(name.length + 2)}^\n    Unsupported ${name} value format\n  `);\n};\n/**\n * @param options\n * @param [options.expandsTo]\n * @param [options.maxValues]\n * @param [options.autoSupported]\n */\nconst expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false, } = {}) => (model, value, container) => {\n    const nodes = parse$1(`${value}`);\n    const parts = [];\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        // value contains `calc`, `url` or other css function\n        // `,`, `/` or strings that unsupported by margin and padding\n        if (node.type === 'function' ||\n            node.type === 'string' ||\n            node.type === 'div') {\n            logError(model, value);\n            return {};\n        }\n        if (node.type === 'word') {\n            if (node.value === 'auto' && autoSupported) {\n                parts.push(node.value);\n            }\n            else {\n                const result = parseUnit(node.value);\n                // when unit isn't specified this condition is true\n                if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n                    parts.push(node.value);\n                }\n                else {\n                    logError(model, value);\n                    return {};\n                }\n            }\n        }\n    }\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n        logError(model, value);\n        return {};\n    }\n    const first = transformUnit(container, parts[0]);\n    if (expandsTo) {\n        const second = transformUnit(container, parts[1] || parts[0]);\n        const third = transformUnit(container, parts[2] || parts[0]);\n        const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\n        return expandsTo({ first, second, third, fourth });\n    }\n    return {\n        [model]: first,\n    };\n};\n\nconst processMargin = expandBoxModel({\n    expandsTo: ({ first, second, third, fourth }) => ({\n        marginTop: first,\n        marginRight: second,\n        marginBottom: third,\n        marginLeft: fourth,\n    }),\n    maxValues: 4,\n    autoSupported: true,\n});\nconst processMarginVertical = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        marginTop: first,\n        marginBottom: second,\n    }),\n    maxValues: 2,\n    autoSupported: true,\n});\nconst processMarginHorizontal = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        marginRight: first,\n        marginLeft: second,\n    }),\n    maxValues: 2,\n    autoSupported: true,\n});\nconst processMarginSingle = expandBoxModel({\n    autoSupported: true,\n});\nconst handlers$5 = {\n    margin: (processMargin),\n    marginBottom: (processMarginSingle),\n    marginHorizontal: (processMarginHorizontal),\n    marginLeft: (processMarginSingle),\n    marginRight: (processMarginSingle),\n    marginTop: (processMarginSingle),\n    marginVertical: (processMarginVertical),\n};\n\nconst processPadding = expandBoxModel({\n    expandsTo: ({ first, second, third, fourth }) => ({\n        paddingTop: first,\n        paddingRight: second,\n        paddingBottom: third,\n        paddingLeft: fourth,\n    }),\n    maxValues: 4,\n});\nconst processPaddingVertical = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        paddingTop: first,\n        paddingBottom: second,\n    }),\n    maxValues: 2,\n});\nconst processPaddingHorizontal = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        paddingRight: first,\n        paddingLeft: second,\n    }),\n    maxValues: 2,\n});\nconst processPaddingSingle = expandBoxModel();\nconst handlers$4 = {\n    padding: (processPadding),\n    paddingBottom: (processPaddingSingle),\n    paddingHorizontal: (processPaddingHorizontal),\n    paddingLeft: (processPaddingSingle),\n    paddingRight: (processPaddingSingle),\n    paddingTop: (processPaddingSingle),\n    paddingVertical: (processPaddingVertical),\n};\n\nconst offsetKeyword = (value) => {\n    switch (value) {\n        case 'top':\n        case 'left':\n            return '0%';\n        case 'right':\n        case 'bottom':\n            return '100%';\n        case 'center':\n            return '50%';\n        default:\n            return value;\n    }\n};\n\nconst processObjectPosition = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const objectPositionX = offsetKeyword(transformUnit(container, match?.[0] || value));\n    const objectPositionY = offsetKeyword(transformUnit(container, match?.[1] || value));\n    return { objectPositionX, objectPositionY };\n};\nconst processObjectPositionValue = (key, value, container) => ({\n    [key]: offsetKeyword(transformUnit(container, value)),\n});\nconst handlers$3 = {\n    objectPosition: (processObjectPosition),\n    objectPositionX: (processObjectPositionValue),\n    objectPositionY: (processObjectPositionValue),\n    objectFit: (processNoopValue),\n};\n\nconst castInt = (value) => {\n    if (typeof value === 'number')\n        return value;\n    return parseInt(value, 10);\n};\n\nconst FONT_WEIGHTS = {\n    thin: 100,\n    hairline: 100,\n    ultralight: 200,\n    extralight: 200,\n    light: 300,\n    normal: 400,\n    medium: 500,\n    semibold: 600,\n    demibold: 600,\n    bold: 700,\n    ultrabold: 800,\n    extrabold: 800,\n    heavy: 900,\n    black: 900,\n};\nconst transformFontWeight = (value) => {\n    if (!value)\n        return FONT_WEIGHTS.normal;\n    if (typeof value === 'number')\n        return value;\n    const lv = value.toLowerCase();\n    if (FONT_WEIGHTS[lv])\n        return FONT_WEIGHTS[lv];\n    return castInt(value);\n};\nconst processFontWeight = (key, value) => {\n    return { [key]: transformFontWeight(value) };\n};\nconst transformLineHeight = (value, styles, container) => {\n    if (value === '')\n        return value;\n    const fontSize = transformUnit(container, styles.fontSize || 18);\n    const lineHeight = transformUnit(container, value);\n    // Percent values: use this number multiplied by the element's font size\n    const { percent } = matchPercent(lineHeight) || {};\n    if (percent)\n        return percent * fontSize;\n    // Unitless values: use this number multiplied by the element's font size\n    return isNaN(value) ? lineHeight : lineHeight * fontSize;\n};\nconst processLineHeight = (key, value, container, styles) => {\n    return {\n        [key]: transformLineHeight(value, styles, container),\n    };\n};\nconst handlers$2 = {\n    direction: (processNoopValue),\n    fontFamily: (processNoopValue),\n    fontSize: (processUnitValue),\n    fontStyle: (processNoopValue),\n    fontWeight: (processFontWeight),\n    letterSpacing: (processUnitValue),\n    lineHeight: (processLineHeight),\n    maxLines: (processNumberValue),\n    textAlign: (processNoopValue),\n    textDecoration: (processNoopValue),\n    textDecorationColor: (processColorValue),\n    textDecorationStyle: (processNoopValue),\n    textIndent: (processNoopValue),\n    textOverflow: (processNoopValue),\n    textTransform: (processNoopValue),\n    verticalAlign: (processNoopValue),\n};\n\nconst matchNumber = (value) => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = (value) => {\n    if (typeof value !== 'string')\n        return value;\n    if (matchNumber(value))\n        return parseFloat(value);\n    return value;\n};\n\nconst parse = (transformString) => {\n    const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n    // Handle \"initial\", \"inherit\", \"unset\".\n    if (transforms.length === 1) {\n        return [[transforms[0], true]];\n    }\n    const parsed = [];\n    for (let i = 0; i < transforms.length; i += 1) {\n        const transform = transforms[i];\n        if (transform) {\n            const [name, rawValue] = transform.split('(');\n            const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n            const value = rawValue.split(splitChar).map((val) => val.trim());\n            parsed.push({ operation: name.trim(), value });\n        }\n    }\n    return parsed;\n};\nconst parseAngle = (value) => {\n    const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n    const [, angle, unit] = unitsRegexp.exec(value);\n    const number = Number.parseFloat(angle);\n    return unit === 'rad' ? (number * 180) / Math.PI : number;\n};\nconst normalizeTransformOperation = ({ operation, value }) => {\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY = scaleX] = value.map((num) => Number.parseFloat(num));\n            return { operation: 'scale', value: [scaleX, scaleY] };\n        }\n        case 'scaleX': {\n            return { operation: 'scale', value: [Number.parseFloat(value), 1] };\n        }\n        case 'scaleY': {\n            return { operation: 'scale', value: [1, Number.parseFloat(value)] };\n        }\n        case 'rotate': {\n            return { operation: 'rotate', value: [parseAngle(value)] };\n        }\n        case 'translate': {\n            return {\n                operation: 'translate',\n                value: value.map((num) => Number.parseFloat(num)),\n            };\n        }\n        case 'translateX': {\n            return {\n                operation: 'translate',\n                value: [Number.parseFloat(value), 0],\n            };\n        }\n        case 'translateY': {\n            return { operation: 'translate', value: [0, Number.parseFloat(value)] };\n        }\n        case 'skew': {\n            return { operation: 'skew', value: value.map(parseAngle) };\n        }\n        case 'skewX': {\n            return { operation: 'skew', value: [parseAngle(value), 0] };\n        }\n        case 'skewY': {\n            return { operation: 'skew', value: [0, parseAngle(value)] };\n        }\n        default: {\n            return { operation, value: value.map((num) => Number.parseFloat(num)) };\n        }\n    }\n};\nconst normalize = (operations) => {\n    return operations.map((operation) => normalizeTransformOperation(operation));\n};\nconst processTransform = (key, value) => {\n    if (typeof value !== 'string')\n        return { [key]: value };\n    return { [key]: normalize(parse(value)) };\n};\nconst Y_AXIS_SHORTHANDS = { top: true, bottom: true };\nconst sortTransformOriginPair = (a, b) => {\n    if (Y_AXIS_SHORTHANDS[a])\n        return 1;\n    if (Y_AXIS_SHORTHANDS[b])\n        return -1;\n    return 0;\n};\nconst getTransformOriginPair = (values) => {\n    if (!values || values.length === 0)\n        return ['center', 'center'];\n    const pair = values.length === 1 ? [values[0], 'center'] : values;\n    return pair.sort(sortTransformOriginPair);\n};\n// Transforms shorthand transformOrigin values\nconst processTransformOriginShorthand = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const pair = getTransformOriginPair(match);\n    const transformOriginX = transformUnit(container, pair[0]);\n    const transformOriginY = transformUnit(container, pair[1]);\n    return {\n        transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\n        transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY),\n    };\n};\nconst processTransformOriginValue = (key, value, container) => {\n    const v = transformUnit(container, value);\n    return { [key]: offsetKeyword(v) || castFloat(v) };\n};\nconst handlers$1 = {\n    transform: processTransform,\n    gradientTransform: processTransform,\n    transformOrigin: (processTransformOriginShorthand),\n    transformOriginX: (processTransformOriginValue),\n    transformOriginY: (processTransformOriginValue),\n};\n\nconst handlers = {\n    fill: (processColorValue),\n    stroke: (processColorValue),\n    strokeDasharray: (processNoopValue),\n    strokeWidth: (processUnitValue),\n    fillOpacity: (processNumberValue),\n    strokeOpacity: (processNumberValue),\n    fillRule: (processNoopValue),\n    textAnchor: (processNoopValue),\n    strokeLinecap: (processNoopValue),\n    strokeLinejoin: (processNoopValue),\n    visibility: (processNoopValue),\n    clipPath: (processNoopValue),\n    dominantBaseline: (processNoopValue),\n};\n\nconst shorthands = {\n    ...handlers$b,\n    ...handlers$a,\n    ...handlers$9,\n    ...handlers$8,\n    ...handlers$7,\n    ...handlers$6,\n    ...handlers$5,\n    ...handlers$4,\n    ...handlers$3,\n    ...handlers$2,\n    ...handlers$1,\n    ...handlers,\n};\n/**\n * Expand the shorthand properties.\n *\n * @param style - Style object\n * @returns Expanded style object\n */\nconst resolve = (container) => (style) => {\n    const propsArray = Object.keys(style);\n    const resolvedStyle = {};\n    for (let i = 0; i < propsArray.length; i += 1) {\n        const key = propsArray[i];\n        const value = style[key];\n        if (!shorthands[key]) {\n            resolvedStyle[key] = value;\n            continue;\n        }\n        const resolved = shorthands[key](key, value, container, style);\n        const keys = Object.keys(resolved);\n        for (let j = 0; j < keys.length; j += 1) {\n            const propName = keys[j];\n            const propValue = resolved[propName];\n            resolvedStyle[propName] = propValue;\n        }\n    }\n    return resolvedStyle;\n};\n\n/**\n * Resolves styles\n *\n * @param container\n * @param style - Style\n * @returns Resolved style\n */\nconst resolveStyles = (container, style) => {\n    const computeMediaQueries = (value) => resolveMediaQueries(container, value);\n    return compose(resolve(container), computeMediaQueries, flatten)(style);\n};\n\nexport { resolveStyles as default, flatten, transformColor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}